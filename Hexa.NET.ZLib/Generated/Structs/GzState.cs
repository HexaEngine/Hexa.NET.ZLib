// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ZLib
{
	/// <summary>
	/// internal gzip file state data structure <br/>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public partial struct GzState
	{
		/// <summary>
		/// "x" for exposed <br/>
		/// x.have: number of bytes available at x.next <br/>
		/// x.next: next output data to deliver or write <br/>
		/// x.pos: current position in uncompressed data <br/>
		/// </summary>
		public GZFile X;

		/// <summary>
		/// see gzip modes above <br/>
		/// </summary>
		public int Mode;

		/// <summary>
		/// file descriptor <br/>
		/// </summary>
		public int Fd;

		/// <summary>
		/// path or fd for error messages <br/>
		/// </summary>
		public unsafe byte* Path;

		/// <summary>
		/// buffer size, zero if not allocated yet <br/>
		/// </summary>
		public uint Size;

		/// <summary>
		/// requested buffer size, default is GZBUFSIZE <br/>
		/// </summary>
		public uint Want;

		/// <summary>
		/// input buffer (double-sized when writing) <br/>
		/// </summary>
		public unsafe byte* In;

		/// <summary>
		/// output buffer (double-sized when reading) <br/>
		/// </summary>
		public unsafe byte* Out;

		/// <summary>
		/// 0 if processing gzip, 1 if transparent <br/>
		/// </summary>
		public int Direct;

		/// <summary>
		/// 0: get header, 1: copy, 2: decompress <br/>
		/// </summary>
		public int How;

		/// <summary>
		/// where the gzip data started, for rewinding <br/>
		/// </summary>
		public long Start;

		/// <summary>
		/// true if end of input file reached <br/>
		/// </summary>
		public int Eof;

		/// <summary>
		/// true if read requested past end <br/>
		/// </summary>
		public int Past;

		/// <summary>
		/// compression level <br/>
		/// </summary>
		public int Level;

		/// <summary>
		/// compression strategy <br/>
		/// </summary>
		public int Strategy;

		/// <summary>
		/// true if a reset is pending after a Z_FINISH <br/>
		/// </summary>
		public int Reset;

		/// <summary>
		/// amount to skip (already rewound if backwards) <br/>
		/// </summary>
		public long Skip;

		/// <summary>
		/// true if seek request pending <br/>
		/// </summary>
		public int Seek;

		/// <summary>
		/// error code <br/>
		/// </summary>
		public int Err;

		/// <summary>
		/// error message <br/>
		/// </summary>
		public unsafe byte* Msg;

		/// <summary>
		/// stream structure in-place (not a pointer) <br/>
		/// </summary>
		public ZStream Strm;


		/// <summary>
		/// To be documented.
		/// </summary>
		public unsafe GzState(GZFile x = default, int mode = default, int fd = default, byte* path = default, uint size = default, uint want = default, byte* input = default, byte* output = default, int direct = default, int how = default, long start = default, int eof = default, int past = default, int level = default, int strategy = default, int reset = default, long skip = default, int seek = default, int err = default, byte* msg = default, ZStream strm = default)
		{
			X = x;
			Mode = mode;
			Fd = fd;
			Path = path;
			Size = size;
			Want = want;
			In = input;
			Out = output;
			Direct = direct;
			How = how;
			Start = start;
			Eof = eof;
			Past = past;
			Level = level;
			Strategy = strategy;
			Reset = reset;
			Skip = skip;
			Seek = seek;
			Err = err;
			Msg = msg;
			Strm = strm;
		}


	}

}
