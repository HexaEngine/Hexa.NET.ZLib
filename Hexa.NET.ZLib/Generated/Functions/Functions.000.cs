// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ZLib
{
	public unsafe partial class ZLib
	{
		/// <summary>
		/// basic functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* VersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[0])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[0])();
			#endif
		}

		/// <summary>
		/// basic functions <br/>
		/// </summary>
		public static byte* Version()
		{
			byte* ret = VersionNative();
			return ret;
		}

		/// <summary>
		/// basic functions <br/>
		/// </summary>
		public static string VersionS()
		{
			string ret = Utils.DecodeStringUTF8(VersionNative());
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);<br/>
		/// Initializes the internal stream state for compression.  The fields<br/>
		/// zalloc, zfree and opaque must be initialized before by the caller.  If<br/>
		/// zalloc and zfree are set to Z_NULL, deflateInit updates them to use default<br/>
		/// allocation functions.  total_in, total_out, adler, and msg are initialized.<br/>
		/// The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:<br/>
		/// 1 gives best speed, 9 gives best compression, 0 gives no compression at all<br/>
		/// (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION<br/>
		/// requests a default compromise between speed and compression (currently<br/>
		/// equivalent to level 6).<br/>
		/// deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_STREAM_ERROR if level is not a valid compression level, or<br/>
		/// Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible<br/>
		/// with the version assumed by the caller (ZLIB_VERSION).  msg is set to null<br/>
		/// if there is no error message.  deflateInit does not perform any compression:<br/>
		/// this will be done by deflate().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateNative(ZStream* strm, int flush)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int>)funcTable[1])(strm, flush);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[1])((nint)strm, flush);
			#endif
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);<br/>
		/// Initializes the internal stream state for compression.  The fields<br/>
		/// zalloc, zfree and opaque must be initialized before by the caller.  If<br/>
		/// zalloc and zfree are set to Z_NULL, deflateInit updates them to use default<br/>
		/// allocation functions.  total_in, total_out, adler, and msg are initialized.<br/>
		/// The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:<br/>
		/// 1 gives best speed, 9 gives best compression, 0 gives no compression at all<br/>
		/// (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION<br/>
		/// requests a default compromise between speed and compression (currently<br/>
		/// equivalent to level 6).<br/>
		/// deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_STREAM_ERROR if level is not a valid compression level, or<br/>
		/// Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible<br/>
		/// with the version assumed by the caller (ZLIB_VERSION).  msg is set to null<br/>
		/// if there is no error message.  deflateInit does not perform any compression:<br/>
		/// this will be done by deflate().<br/>
		/// </summary>
		public static int Deflate(ZStream* strm, int flush)
		{
			int ret = DeflateNative(strm, flush);
			return ret;
		}

		/// <summary>
		/// deflate compresses as much data as possible, and stops when the input<br/>
		/// buffer becomes empty or the output buffer becomes full.  It may introduce<br/>
		/// some output latency (reading input without producing any output) except when<br/>
		/// forced to flush.<br/>
		/// The detailed semantics are as follows.  deflate performs one or both of the<br/>
		/// following actions:<br/>
		/// - Compress more input starting at next_in and update next_in and avail_in<br/>
		/// accordingly.  If not all input can be processed (because there is not<br/>
		/// enough room in the output buffer), next_in and avail_in are updated and<br/>
		/// processing will resume at this point for the next call of deflate().<br/>
		/// - Generate more output starting at next_out and update next_out and avail_out<br/>
		/// accordingly.  This action is forced if the parameter flush is non zero.<br/>
		/// Forcing flush frequently degrades the compression ratio, so this parameter<br/>
		/// should be set only when necessary.  Some output may be provided even if<br/>
		/// flush is zero.<br/>
		/// Before the call of deflate(), the application should ensure that at least<br/>
		/// one of the actions is possible, by providing more input and/or consuming more<br/>
		/// output, and updating avail_in or avail_out accordingly; avail_out should<br/>
		/// never be zero before the call.  The application can consume the compressed<br/>
		/// output when it wants, for example when the output buffer is full (avail_out<br/>
		/// == 0), or after each call of deflate().  If deflate returns Z_OK and with<br/>
		/// zero avail_out, it must be called again after making room in the output<br/>
		/// buffer because there might be more output pending. See deflatePending(),<br/>
		/// which can be used if desired to determine whether or not there is more output<br/>
		/// in that case.<br/>
		/// Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to<br/>
		/// decide how much data to accumulate before producing output, in order to<br/>
		/// maximize compression.<br/>
		/// If the parameter flush is set to Z_SYNC_FLUSH, all pending output is<br/>
		/// flushed to the output buffer and the output is aligned on a byte boundary, so<br/>
		/// that the decompressor can get all input data available so far.  (In<br/>
		/// particular avail_in is zero after the call if enough output space has been<br/>
		/// provided before the call.) Flushing may degrade compression for some<br/>
		/// compression algorithms and so it should be used only when necessary.  This<br/>
		/// completes the current deflate block and follows it with an empty stored block<br/>
		/// that is three bits plus filler bits to the next byte, followed by four bytes<br/>
		/// (00 00 ff ff).<br/>
		/// If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the<br/>
		/// output buffer, but the output is not aligned to a byte boundary.  All of the<br/>
		/// input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.<br/>
		/// This completes the current deflate block and follows it with an empty fixed<br/>
		/// codes block that is 10 bits long.  This assures that enough bytes are output<br/>
		/// in order for the decompressor to finish the block before the empty fixed<br/>
		/// codes block.<br/>
		/// If flush is set to Z_BLOCK, a deflate block is completed and emitted, as<br/>
		/// for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to<br/>
		/// seven bits of the current block are held to be written as the next byte after<br/>
		/// the next deflate block is completed.  In this case, the decompressor may not<br/>
		/// be provided enough bits at this point in order to complete decompression of<br/>
		/// the data provided so far to the compressor.  It may need to wait for the next<br/>
		/// block to be emitted.  This is for advanced applications that need to control<br/>
		/// the emission of deflate blocks.<br/>
		/// If flush is set to Z_FULL_FLUSH, all output is flushed as with<br/>
		/// Z_SYNC_FLUSH, and the compression state is reset so that decompression can<br/>
		/// restart from this point if previous compressed data has been damaged or if<br/>
		/// random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade<br/>
		/// compression.<br/>
		/// If deflate returns with avail_out == 0, this function must be called again<br/>
		/// with the same value of the flush parameter and more output space (updated<br/>
		/// avail_out), until the flush is complete (deflate returns with non-zero<br/>
		/// avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that<br/>
		/// avail_out is greater than six when the flush marker begins, in order to avoid<br/>
		/// repeated flush markers upon calling deflate() again when avail_out == 0.<br/>
		/// If the parameter flush is set to Z_FINISH, pending input is processed,<br/>
		/// pending output is flushed and deflate returns with Z_STREAM_END if there was<br/>
		/// enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this<br/>
		/// function must be called again with Z_FINISH and more output space (updated<br/>
		/// avail_out) but no more input data, until it returns with Z_STREAM_END or an<br/>
		/// error.  After deflate has returned Z_STREAM_END, the only possible operations<br/>
		/// on the stream are deflateReset or deflateEnd.<br/>
		/// Z_FINISH can be used in the first deflate call after deflateInit if all the<br/>
		/// compression is to be done in a single step.  In order to complete in one<br/>
		/// call, avail_out must be at least the value returned by deflateBound (see<br/>
		/// below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough<br/>
		/// output space is provided, deflate will not return Z_STREAM_END, and it must<br/>
		/// be called again as described above.<br/>
		/// deflate() sets strm->adler to the Adler-32 checksum of all input read<br/>
		/// so far (that is, total_in bytes).  If a gzip stream is being generated, then<br/>
		/// strm->adler will be the CRC-32 checksum of the input read so far.  (See<br/>
		/// deflateInit2 below.)<br/>
		/// deflate() may update strm->data_type if it can make a good guess about<br/>
		/// the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is<br/>
		/// considered binary.  This field is only for information purposes and does not<br/>
		/// affect the compression algorithm in any manner.<br/>
		/// deflate() returns Z_OK if some progress has been made (more input<br/>
		/// processed or more output produced), Z_STREAM_END if all input has been<br/>
		/// consumed and all output has been produced (only when flush is set to<br/>
		/// Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example<br/>
		/// if next_in or next_out was Z_NULL or the state was inadvertently written over<br/>
		/// by the application), or Z_BUF_ERROR if no progress is possible (for example<br/>
		/// avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and<br/>
		/// deflate() can be called again with more input and more output space to<br/>
		/// continue compressing.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateEndNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[2])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[2])((nint)strm);
			#endif
		}

		/// <summary>
		/// deflate compresses as much data as possible, and stops when the input<br/>
		/// buffer becomes empty or the output buffer becomes full.  It may introduce<br/>
		/// some output latency (reading input without producing any output) except when<br/>
		/// forced to flush.<br/>
		/// The detailed semantics are as follows.  deflate performs one or both of the<br/>
		/// following actions:<br/>
		/// - Compress more input starting at next_in and update next_in and avail_in<br/>
		/// accordingly.  If not all input can be processed (because there is not<br/>
		/// enough room in the output buffer), next_in and avail_in are updated and<br/>
		/// processing will resume at this point for the next call of deflate().<br/>
		/// - Generate more output starting at next_out and update next_out and avail_out<br/>
		/// accordingly.  This action is forced if the parameter flush is non zero.<br/>
		/// Forcing flush frequently degrades the compression ratio, so this parameter<br/>
		/// should be set only when necessary.  Some output may be provided even if<br/>
		/// flush is zero.<br/>
		/// Before the call of deflate(), the application should ensure that at least<br/>
		/// one of the actions is possible, by providing more input and/or consuming more<br/>
		/// output, and updating avail_in or avail_out accordingly; avail_out should<br/>
		/// never be zero before the call.  The application can consume the compressed<br/>
		/// output when it wants, for example when the output buffer is full (avail_out<br/>
		/// == 0), or after each call of deflate().  If deflate returns Z_OK and with<br/>
		/// zero avail_out, it must be called again after making room in the output<br/>
		/// buffer because there might be more output pending. See deflatePending(),<br/>
		/// which can be used if desired to determine whether or not there is more output<br/>
		/// in that case.<br/>
		/// Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to<br/>
		/// decide how much data to accumulate before producing output, in order to<br/>
		/// maximize compression.<br/>
		/// If the parameter flush is set to Z_SYNC_FLUSH, all pending output is<br/>
		/// flushed to the output buffer and the output is aligned on a byte boundary, so<br/>
		/// that the decompressor can get all input data available so far.  (In<br/>
		/// particular avail_in is zero after the call if enough output space has been<br/>
		/// provided before the call.) Flushing may degrade compression for some<br/>
		/// compression algorithms and so it should be used only when necessary.  This<br/>
		/// completes the current deflate block and follows it with an empty stored block<br/>
		/// that is three bits plus filler bits to the next byte, followed by four bytes<br/>
		/// (00 00 ff ff).<br/>
		/// If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the<br/>
		/// output buffer, but the output is not aligned to a byte boundary.  All of the<br/>
		/// input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.<br/>
		/// This completes the current deflate block and follows it with an empty fixed<br/>
		/// codes block that is 10 bits long.  This assures that enough bytes are output<br/>
		/// in order for the decompressor to finish the block before the empty fixed<br/>
		/// codes block.<br/>
		/// If flush is set to Z_BLOCK, a deflate block is completed and emitted, as<br/>
		/// for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to<br/>
		/// seven bits of the current block are held to be written as the next byte after<br/>
		/// the next deflate block is completed.  In this case, the decompressor may not<br/>
		/// be provided enough bits at this point in order to complete decompression of<br/>
		/// the data provided so far to the compressor.  It may need to wait for the next<br/>
		/// block to be emitted.  This is for advanced applications that need to control<br/>
		/// the emission of deflate blocks.<br/>
		/// If flush is set to Z_FULL_FLUSH, all output is flushed as with<br/>
		/// Z_SYNC_FLUSH, and the compression state is reset so that decompression can<br/>
		/// restart from this point if previous compressed data has been damaged or if<br/>
		/// random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade<br/>
		/// compression.<br/>
		/// If deflate returns with avail_out == 0, this function must be called again<br/>
		/// with the same value of the flush parameter and more output space (updated<br/>
		/// avail_out), until the flush is complete (deflate returns with non-zero<br/>
		/// avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that<br/>
		/// avail_out is greater than six when the flush marker begins, in order to avoid<br/>
		/// repeated flush markers upon calling deflate() again when avail_out == 0.<br/>
		/// If the parameter flush is set to Z_FINISH, pending input is processed,<br/>
		/// pending output is flushed and deflate returns with Z_STREAM_END if there was<br/>
		/// enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this<br/>
		/// function must be called again with Z_FINISH and more output space (updated<br/>
		/// avail_out) but no more input data, until it returns with Z_STREAM_END or an<br/>
		/// error.  After deflate has returned Z_STREAM_END, the only possible operations<br/>
		/// on the stream are deflateReset or deflateEnd.<br/>
		/// Z_FINISH can be used in the first deflate call after deflateInit if all the<br/>
		/// compression is to be done in a single step.  In order to complete in one<br/>
		/// call, avail_out must be at least the value returned by deflateBound (see<br/>
		/// below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough<br/>
		/// output space is provided, deflate will not return Z_STREAM_END, and it must<br/>
		/// be called again as described above.<br/>
		/// deflate() sets strm->adler to the Adler-32 checksum of all input read<br/>
		/// so far (that is, total_in bytes).  If a gzip stream is being generated, then<br/>
		/// strm->adler will be the CRC-32 checksum of the input read so far.  (See<br/>
		/// deflateInit2 below.)<br/>
		/// deflate() may update strm->data_type if it can make a good guess about<br/>
		/// the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is<br/>
		/// considered binary.  This field is only for information purposes and does not<br/>
		/// affect the compression algorithm in any manner.<br/>
		/// deflate() returns Z_OK if some progress has been made (more input<br/>
		/// processed or more output produced), Z_STREAM_END if all input has been<br/>
		/// consumed and all output has been produced (only when flush is set to<br/>
		/// Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example<br/>
		/// if next_in or next_out was Z_NULL or the state was inadvertently written over<br/>
		/// by the application), or Z_BUF_ERROR if no progress is possible (for example<br/>
		/// avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and<br/>
		/// deflate() can be called again with more input and more output space to<br/>
		/// continue compressing.<br/>
		/// </summary>
		public static int DeflateEnd(ZStream* strm)
		{
			int ret = DeflateEndNative(strm);
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT inflateInit(z_streamp strm);<br/>
		/// Initializes the internal stream state for decompression.  The fields<br/>
		/// next_in, avail_in, zalloc, zfree and opaque must be initialized before by<br/>
		/// the caller.  In the current version of inflate, the provided input is not<br/>
		/// read or consumed.  The allocation of a sliding window will be deferred to<br/>
		/// the first call of inflate (if the decompression does not complete on the<br/>
		/// first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates<br/>
		/// them to use default allocation functions.  total_in, total_out, adler, and<br/>
		/// msg are initialized.<br/>
		/// inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_VERSION_ERROR if the zlib library version is incompatible with the<br/>
		/// version assumed by the caller, or Z_STREAM_ERROR if the parameters are<br/>
		/// invalid, such as a null pointer to the structure.  msg is set to null if<br/>
		/// there is no error message.  inflateInit does not perform any decompression.<br/>
		/// Actual decompression will be done by inflate().  So next_in, and avail_in,<br/>
		/// next_out, and avail_out are unused and unchanged.  The current<br/>
		/// implementation of inflateInit() does not process any header information --<br/>
		/// that is deferred until inflate() is called.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateNative(ZStream* strm, int flush)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int>)funcTable[3])(strm, flush);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[3])((nint)strm, flush);
			#endif
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT inflateInit(z_streamp strm);<br/>
		/// Initializes the internal stream state for decompression.  The fields<br/>
		/// next_in, avail_in, zalloc, zfree and opaque must be initialized before by<br/>
		/// the caller.  In the current version of inflate, the provided input is not<br/>
		/// read or consumed.  The allocation of a sliding window will be deferred to<br/>
		/// the first call of inflate (if the decompression does not complete on the<br/>
		/// first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates<br/>
		/// them to use default allocation functions.  total_in, total_out, adler, and<br/>
		/// msg are initialized.<br/>
		/// inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_VERSION_ERROR if the zlib library version is incompatible with the<br/>
		/// version assumed by the caller, or Z_STREAM_ERROR if the parameters are<br/>
		/// invalid, such as a null pointer to the structure.  msg is set to null if<br/>
		/// there is no error message.  inflateInit does not perform any decompression.<br/>
		/// Actual decompression will be done by inflate().  So next_in, and avail_in,<br/>
		/// next_out, and avail_out are unused and unchanged.  The current<br/>
		/// implementation of inflateInit() does not process any header information --<br/>
		/// that is deferred until inflate() is called.<br/>
		/// </summary>
		public static int Inflate(ZStream* strm, int flush)
		{
			int ret = InflateNative(strm, flush);
			return ret;
		}

		/// <summary>
		/// inflate decompresses as much data as possible, and stops when the input<br/>
		/// buffer becomes empty or the output buffer becomes full.  It may introduce<br/>
		/// some output latency (reading input without producing any output) except when<br/>
		/// forced to flush.<br/>
		/// The detailed semantics are as follows.  inflate performs one or both of the<br/>
		/// following actions:<br/>
		/// - Decompress more input starting at next_in and update next_in and avail_in<br/>
		/// accordingly.  If not all input can be processed (because there is not<br/>
		/// enough room in the output buffer), then next_in and avail_in are updated<br/>
		/// accordingly, and processing will resume at this point for the next call of<br/>
		/// inflate().<br/>
		/// - Generate more output starting at next_out and update next_out and avail_out<br/>
		/// accordingly.  inflate() provides as much output as possible, until there is<br/>
		/// no more input data or no more space in the output buffer (see below about<br/>
		/// the flush parameter).<br/>
		/// Before the call of inflate(), the application should ensure that at least<br/>
		/// one of the actions is possible, by providing more input and/or consuming more<br/>
		/// output, and updating the next_* and avail_* values accordingly.  If the<br/>
		/// caller of inflate() does not provide both available input and available<br/>
		/// output space, it is possible that there will be no progress made.  The<br/>
		/// application can consume the uncompressed output when it wants, for example<br/>
		/// when the output buffer is full (avail_out == 0), or after each call of<br/>
		/// inflate().  If inflate returns Z_OK and with zero avail_out, it must be<br/>
		/// called again after making room in the output buffer because there might be<br/>
		/// more output pending.<br/>
		/// The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,<br/>
		/// Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much<br/>
		/// output as possible to the output buffer.  Z_BLOCK requests that inflate()<br/>
		/// stop if and when it gets to the next deflate block boundary.  When decoding<br/>
		/// the zlib or gzip format, this will cause inflate() to return immediately<br/>
		/// after the header and before the first block.  When doing a raw inflate,<br/>
		/// inflate() will go ahead and process the first block, and will return when it<br/>
		/// gets to the end of that block, or when it runs out of data.<br/>
		/// The Z_BLOCK option assists in appending to or combining deflate streams.<br/>
		/// To assist in this, on return inflate() always sets strm->data_type to the<br/>
		/// number of unused bits in the last byte taken from strm->next_in, plus 64 if<br/>
		/// inflate() is currently decoding the last block in the deflate stream, plus<br/>
		/// 128 if inflate() returned immediately after decoding an end-of-block code or<br/>
		/// decoding the complete header up to just before the first byte of the deflate<br/>
		/// stream.  The end-of-block will not be indicated until all of the uncompressed<br/>
		/// data from that block has been written to strm->next_out.  The number of<br/>
		/// unused bits may in general be greater than seven, except when bit 7 of<br/>
		/// data_type is set, in which case the number of unused bits will be less than<br/>
		/// eight.  data_type is set as noted here every time inflate() returns for all<br/>
		/// flush options, and so can be used to determine the amount of currently<br/>
		/// consumed input in bits.<br/>
		/// The Z_TREES option behaves as Z_BLOCK does, but it also returns when the<br/>
		/// end of each deflate block header is reached, before any actual data in that<br/>
		/// block is decoded.  This allows the caller to determine the length of the<br/>
		/// deflate block header for later use in random access within a deflate block.<br/>
		/// 256 is added to the value of strm->data_type when inflate() returns<br/>
		/// immediately after reaching the end of the deflate block header.<br/>
		/// inflate() should normally be called until it returns Z_STREAM_END or an<br/>
		/// error.  However if all decompression is to be performed in a single step (a<br/>
		/// single call of inflate), the parameter flush should be set to Z_FINISH.  In<br/>
		/// this case all pending input is processed and all pending output is flushed;<br/>
		/// avail_out must be large enough to hold all of the uncompressed data for the<br/>
		/// operation to complete.  (The size of the uncompressed data may have been<br/>
		/// saved by the compressor for this purpose.)  The use of Z_FINISH is not<br/>
		/// required to perform an inflation in one step.  However it may be used to<br/>
		/// inform inflate that a faster approach can be used for the single inflate()<br/>
		/// call.  Z_FINISH also informs inflate to not maintain a sliding window if the<br/>
		/// stream completes, which reduces inflate's memory footprint.  If the stream<br/>
		/// does not complete, either because not all of the stream is provided or not<br/>
		/// enough output space is provided, then a sliding window will be allocated and<br/>
		/// inflate() can be called again to continue the operation as if Z_NO_FLUSH had<br/>
		/// been used.<br/>
		/// In this implementation, inflate() always flushes as much output as<br/>
		/// possible to the output buffer, and always uses the faster approach on the<br/>
		/// first call.  So the effects of the flush parameter in this implementation are<br/>
		/// on the return value of inflate() as noted below, when inflate() returns early<br/>
		/// when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of<br/>
		/// memory for a sliding window when Z_FINISH is used.<br/>
		/// If a preset dictionary is needed after this call (see inflateSetDictionary<br/>
		/// below), inflate sets strm->adler to the Adler-32 checksum of the dictionary<br/>
		/// chosen by the compressor and returns Z_NEED_DICT; otherwise it sets<br/>
		/// strm->adler to the Adler-32 checksum of all output produced so far (that is,<br/>
		/// total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described<br/>
		/// below.  At the end of the stream, inflate() checks that its computed Adler-32<br/>
		/// checksum is equal to that saved by the compressor and returns Z_STREAM_END<br/>
		/// only if the checksum is correct.<br/>
		/// inflate() can decompress and check either zlib-wrapped or gzip-wrapped<br/>
		/// deflate data.  The header type is detected automatically, if requested when<br/>
		/// initializing with inflateInit2().  Any information contained in the gzip<br/>
		/// header is not retained unless inflateGetHeader() is used.  When processing<br/>
		/// gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output<br/>
		/// produced so far.  The CRC-32 is checked against the gzip trailer, as is the<br/>
		/// uncompressed length, modulo 2^32.<br/>
		/// inflate() returns Z_OK if some progress has been made (more input processed<br/>
		/// or more output produced), Z_STREAM_END if the end of the compressed data has<br/>
		/// been reached and all uncompressed output has been produced, Z_NEED_DICT if a<br/>
		/// preset dictionary is needed at this point, Z_DATA_ERROR if the input data was<br/>
		/// corrupted (input stream not conforming to the zlib format or incorrect check<br/>
		/// value, in which case strm->msg points to a string with a more specific<br/>
		/// error), Z_STREAM_ERROR if the stream structure was inconsistent (for example<br/>
		/// next_in or next_out was Z_NULL, or the state was inadvertently written over<br/>
		/// by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR<br/>
		/// if no progress was possible or if there was not enough room in the output<br/>
		/// buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and<br/>
		/// inflate() can be called again with more input and more output space to<br/>
		/// continue decompressing.  If Z_DATA_ERROR is returned, the application may<br/>
		/// then call inflateSync() to look for a good compression block if a partial<br/>
		/// recovery of the data is to be attempted.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateEndNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[4])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[4])((nint)strm);
			#endif
		}

		/// <summary>
		/// inflate decompresses as much data as possible, and stops when the input<br/>
		/// buffer becomes empty or the output buffer becomes full.  It may introduce<br/>
		/// some output latency (reading input without producing any output) except when<br/>
		/// forced to flush.<br/>
		/// The detailed semantics are as follows.  inflate performs one or both of the<br/>
		/// following actions:<br/>
		/// - Decompress more input starting at next_in and update next_in and avail_in<br/>
		/// accordingly.  If not all input can be processed (because there is not<br/>
		/// enough room in the output buffer), then next_in and avail_in are updated<br/>
		/// accordingly, and processing will resume at this point for the next call of<br/>
		/// inflate().<br/>
		/// - Generate more output starting at next_out and update next_out and avail_out<br/>
		/// accordingly.  inflate() provides as much output as possible, until there is<br/>
		/// no more input data or no more space in the output buffer (see below about<br/>
		/// the flush parameter).<br/>
		/// Before the call of inflate(), the application should ensure that at least<br/>
		/// one of the actions is possible, by providing more input and/or consuming more<br/>
		/// output, and updating the next_* and avail_* values accordingly.  If the<br/>
		/// caller of inflate() does not provide both available input and available<br/>
		/// output space, it is possible that there will be no progress made.  The<br/>
		/// application can consume the uncompressed output when it wants, for example<br/>
		/// when the output buffer is full (avail_out == 0), or after each call of<br/>
		/// inflate().  If inflate returns Z_OK and with zero avail_out, it must be<br/>
		/// called again after making room in the output buffer because there might be<br/>
		/// more output pending.<br/>
		/// The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,<br/>
		/// Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much<br/>
		/// output as possible to the output buffer.  Z_BLOCK requests that inflate()<br/>
		/// stop if and when it gets to the next deflate block boundary.  When decoding<br/>
		/// the zlib or gzip format, this will cause inflate() to return immediately<br/>
		/// after the header and before the first block.  When doing a raw inflate,<br/>
		/// inflate() will go ahead and process the first block, and will return when it<br/>
		/// gets to the end of that block, or when it runs out of data.<br/>
		/// The Z_BLOCK option assists in appending to or combining deflate streams.<br/>
		/// To assist in this, on return inflate() always sets strm->data_type to the<br/>
		/// number of unused bits in the last byte taken from strm->next_in, plus 64 if<br/>
		/// inflate() is currently decoding the last block in the deflate stream, plus<br/>
		/// 128 if inflate() returned immediately after decoding an end-of-block code or<br/>
		/// decoding the complete header up to just before the first byte of the deflate<br/>
		/// stream.  The end-of-block will not be indicated until all of the uncompressed<br/>
		/// data from that block has been written to strm->next_out.  The number of<br/>
		/// unused bits may in general be greater than seven, except when bit 7 of<br/>
		/// data_type is set, in which case the number of unused bits will be less than<br/>
		/// eight.  data_type is set as noted here every time inflate() returns for all<br/>
		/// flush options, and so can be used to determine the amount of currently<br/>
		/// consumed input in bits.<br/>
		/// The Z_TREES option behaves as Z_BLOCK does, but it also returns when the<br/>
		/// end of each deflate block header is reached, before any actual data in that<br/>
		/// block is decoded.  This allows the caller to determine the length of the<br/>
		/// deflate block header for later use in random access within a deflate block.<br/>
		/// 256 is added to the value of strm->data_type when inflate() returns<br/>
		/// immediately after reaching the end of the deflate block header.<br/>
		/// inflate() should normally be called until it returns Z_STREAM_END or an<br/>
		/// error.  However if all decompression is to be performed in a single step (a<br/>
		/// single call of inflate), the parameter flush should be set to Z_FINISH.  In<br/>
		/// this case all pending input is processed and all pending output is flushed;<br/>
		/// avail_out must be large enough to hold all of the uncompressed data for the<br/>
		/// operation to complete.  (The size of the uncompressed data may have been<br/>
		/// saved by the compressor for this purpose.)  The use of Z_FINISH is not<br/>
		/// required to perform an inflation in one step.  However it may be used to<br/>
		/// inform inflate that a faster approach can be used for the single inflate()<br/>
		/// call.  Z_FINISH also informs inflate to not maintain a sliding window if the<br/>
		/// stream completes, which reduces inflate's memory footprint.  If the stream<br/>
		/// does not complete, either because not all of the stream is provided or not<br/>
		/// enough output space is provided, then a sliding window will be allocated and<br/>
		/// inflate() can be called again to continue the operation as if Z_NO_FLUSH had<br/>
		/// been used.<br/>
		/// In this implementation, inflate() always flushes as much output as<br/>
		/// possible to the output buffer, and always uses the faster approach on the<br/>
		/// first call.  So the effects of the flush parameter in this implementation are<br/>
		/// on the return value of inflate() as noted below, when inflate() returns early<br/>
		/// when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of<br/>
		/// memory for a sliding window when Z_FINISH is used.<br/>
		/// If a preset dictionary is needed after this call (see inflateSetDictionary<br/>
		/// below), inflate sets strm->adler to the Adler-32 checksum of the dictionary<br/>
		/// chosen by the compressor and returns Z_NEED_DICT; otherwise it sets<br/>
		/// strm->adler to the Adler-32 checksum of all output produced so far (that is,<br/>
		/// total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described<br/>
		/// below.  At the end of the stream, inflate() checks that its computed Adler-32<br/>
		/// checksum is equal to that saved by the compressor and returns Z_STREAM_END<br/>
		/// only if the checksum is correct.<br/>
		/// inflate() can decompress and check either zlib-wrapped or gzip-wrapped<br/>
		/// deflate data.  The header type is detected automatically, if requested when<br/>
		/// initializing with inflateInit2().  Any information contained in the gzip<br/>
		/// header is not retained unless inflateGetHeader() is used.  When processing<br/>
		/// gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output<br/>
		/// produced so far.  The CRC-32 is checked against the gzip trailer, as is the<br/>
		/// uncompressed length, modulo 2^32.<br/>
		/// inflate() returns Z_OK if some progress has been made (more input processed<br/>
		/// or more output produced), Z_STREAM_END if the end of the compressed data has<br/>
		/// been reached and all uncompressed output has been produced, Z_NEED_DICT if a<br/>
		/// preset dictionary is needed at this point, Z_DATA_ERROR if the input data was<br/>
		/// corrupted (input stream not conforming to the zlib format or incorrect check<br/>
		/// value, in which case strm->msg points to a string with a more specific<br/>
		/// error), Z_STREAM_ERROR if the stream structure was inconsistent (for example<br/>
		/// next_in or next_out was Z_NULL, or the state was inadvertently written over<br/>
		/// by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR<br/>
		/// if no progress was possible or if there was not enough room in the output<br/>
		/// buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and<br/>
		/// inflate() can be called again with more input and more output space to<br/>
		/// continue decompressing.  If Z_DATA_ERROR is returned, the application may<br/>
		/// then call inflateSync() to look for a good compression block if a partial<br/>
		/// recovery of the data is to be attempted.<br/>
		/// </summary>
		public static int InflateEnd(ZStream* strm)
		{
			int ret = InflateEndNative(strm);
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,<br/>
		/// int level,<br/>
		/// int method,<br/>
		/// int windowBits,<br/>
		/// int memLevel,<br/>
		/// int strategy);<br/>
		/// This is another version of deflateInit with more compression options.  The<br/>
		/// fields zalloc, zfree and opaque must be initialized before by the caller.<br/>
		/// The method parameter is the compression method.  It must be Z_DEFLATED in<br/>
		/// this version of the library.<br/>
		/// The windowBits parameter is the base two logarithm of the window size<br/>
		/// (the size of the history buffer).  It should be in the range 8..15 for this<br/>
		/// version of the library.  Larger values of this parameter result in better<br/>
		/// compression at the expense of memory usage.  The default value is 15 if<br/>
		/// deflateInit is used instead.<br/>
		/// For the current implementation of deflate(), a windowBits value of 8 (a<br/>
		/// window size of 256 bytes) is not supported.  As a result, a request for 8<br/>
		/// will result in 9 (a 512-byte window).  In that case, providing 8 to<br/>
		/// inflateInit2() will result in an error when the zlib header with 9 is<br/>
		/// checked against the initialization of inflate().  The remedy is to not use 8<br/>
		/// with deflateInit2() with this initialization, or at least in that case use 9<br/>
		/// with inflateInit2().<br/>
		/// windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits<br/>
		/// determines the window size.  deflate() will then generate raw deflate data<br/>
		/// with no zlib header or trailer, and will not compute a check value.<br/>
		/// windowBits can also be greater than 15 for optional gzip encoding.  Add<br/>
		/// 16 to windowBits to write a simple gzip header and trailer around the<br/>
		/// compressed data instead of a zlib wrapper.  The gzip header will have no<br/>
		/// file name, no extra data, no comment, no modification time (set to zero), no<br/>
		/// header crc, and the operating system will be set to the appropriate value,<br/>
		/// if the operating system was determined at compile time.  If a gzip stream is<br/>
		/// being written, strm->adler is a CRC-32 instead of an Adler-32.<br/>
		/// For raw deflate or gzip encoding, a request for a 256-byte window is<br/>
		/// rejected as invalid, since only the zlib header provides a means of<br/>
		/// transmitting the window size to the decompressor.<br/>
		/// The memLevel parameter specifies how much memory should be allocated<br/>
		/// for the internal compression state.  memLevel=1 uses minimum memory but is<br/>
		/// slow and reduces compression ratio; memLevel=9 uses maximum memory for<br/>
		/// optimal speed.  The default value is 8.  See zconf.h for total memory usage<br/>
		/// as a function of windowBits and memLevel.<br/>
		/// The strategy parameter is used to tune the compression algorithm.  Use the<br/>
		/// value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a<br/>
		/// filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no<br/>
		/// string match), or Z_RLE to limit match distances to one (run-length<br/>
		/// encoding).  Filtered data consists mostly of small values with a somewhat<br/>
		/// random distribution.  In this case, the compression algorithm is tuned to<br/>
		/// compress them better.  The effect of Z_FILTERED is to force more Huffman<br/>
		/// coding and less string matching; it is somewhat intermediate between<br/>
		/// Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as<br/>
		/// fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The<br/>
		/// strategy parameter only affects the compression ratio but not the<br/>
		/// correctness of the compressed output even if it is not set appropriately.<br/>
		/// Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler<br/>
		/// decoder for special applications.<br/>
		/// deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid<br/>
		/// method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is<br/>
		/// incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is<br/>
		/// set to null if there is no error message.  deflateInit2 does not perform any<br/>
		/// compression: this will be done by deflate().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateSetDictionaryNative(ZStream* strm, byte* dictionary, uint dictLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, byte*, uint, int>)funcTable[5])(strm, dictionary, dictLength);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, int>)funcTable[5])((nint)strm, (nint)dictionary, dictLength);
			#endif
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,<br/>
		/// int level,<br/>
		/// int method,<br/>
		/// int windowBits,<br/>
		/// int memLevel,<br/>
		/// int strategy);<br/>
		/// This is another version of deflateInit with more compression options.  The<br/>
		/// fields zalloc, zfree and opaque must be initialized before by the caller.<br/>
		/// The method parameter is the compression method.  It must be Z_DEFLATED in<br/>
		/// this version of the library.<br/>
		/// The windowBits parameter is the base two logarithm of the window size<br/>
		/// (the size of the history buffer).  It should be in the range 8..15 for this<br/>
		/// version of the library.  Larger values of this parameter result in better<br/>
		/// compression at the expense of memory usage.  The default value is 15 if<br/>
		/// deflateInit is used instead.<br/>
		/// For the current implementation of deflate(), a windowBits value of 8 (a<br/>
		/// window size of 256 bytes) is not supported.  As a result, a request for 8<br/>
		/// will result in 9 (a 512-byte window).  In that case, providing 8 to<br/>
		/// inflateInit2() will result in an error when the zlib header with 9 is<br/>
		/// checked against the initialization of inflate().  The remedy is to not use 8<br/>
		/// with deflateInit2() with this initialization, or at least in that case use 9<br/>
		/// with inflateInit2().<br/>
		/// windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits<br/>
		/// determines the window size.  deflate() will then generate raw deflate data<br/>
		/// with no zlib header or trailer, and will not compute a check value.<br/>
		/// windowBits can also be greater than 15 for optional gzip encoding.  Add<br/>
		/// 16 to windowBits to write a simple gzip header and trailer around the<br/>
		/// compressed data instead of a zlib wrapper.  The gzip header will have no<br/>
		/// file name, no extra data, no comment, no modification time (set to zero), no<br/>
		/// header crc, and the operating system will be set to the appropriate value,<br/>
		/// if the operating system was determined at compile time.  If a gzip stream is<br/>
		/// being written, strm->adler is a CRC-32 instead of an Adler-32.<br/>
		/// For raw deflate or gzip encoding, a request for a 256-byte window is<br/>
		/// rejected as invalid, since only the zlib header provides a means of<br/>
		/// transmitting the window size to the decompressor.<br/>
		/// The memLevel parameter specifies how much memory should be allocated<br/>
		/// for the internal compression state.  memLevel=1 uses minimum memory but is<br/>
		/// slow and reduces compression ratio; memLevel=9 uses maximum memory for<br/>
		/// optimal speed.  The default value is 8.  See zconf.h for total memory usage<br/>
		/// as a function of windowBits and memLevel.<br/>
		/// The strategy parameter is used to tune the compression algorithm.  Use the<br/>
		/// value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a<br/>
		/// filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no<br/>
		/// string match), or Z_RLE to limit match distances to one (run-length<br/>
		/// encoding).  Filtered data consists mostly of small values with a somewhat<br/>
		/// random distribution.  In this case, the compression algorithm is tuned to<br/>
		/// compress them better.  The effect of Z_FILTERED is to force more Huffman<br/>
		/// coding and less string matching; it is somewhat intermediate between<br/>
		/// Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as<br/>
		/// fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The<br/>
		/// strategy parameter only affects the compression ratio but not the<br/>
		/// correctness of the compressed output even if it is not set appropriately.<br/>
		/// Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler<br/>
		/// decoder for special applications.<br/>
		/// deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid<br/>
		/// method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is<br/>
		/// incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is<br/>
		/// set to null if there is no error message.  deflateInit2 does not perform any<br/>
		/// compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateSetDictionary(ZStream* strm, byte* dictionary, uint dictLength)
		{
			int ret = DeflateSetDictionaryNative(strm, dictionary, dictLength);
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,<br/>
		/// int level,<br/>
		/// int method,<br/>
		/// int windowBits,<br/>
		/// int memLevel,<br/>
		/// int strategy);<br/>
		/// This is another version of deflateInit with more compression options.  The<br/>
		/// fields zalloc, zfree and opaque must be initialized before by the caller.<br/>
		/// The method parameter is the compression method.  It must be Z_DEFLATED in<br/>
		/// this version of the library.<br/>
		/// The windowBits parameter is the base two logarithm of the window size<br/>
		/// (the size of the history buffer).  It should be in the range 8..15 for this<br/>
		/// version of the library.  Larger values of this parameter result in better<br/>
		/// compression at the expense of memory usage.  The default value is 15 if<br/>
		/// deflateInit is used instead.<br/>
		/// For the current implementation of deflate(), a windowBits value of 8 (a<br/>
		/// window size of 256 bytes) is not supported.  As a result, a request for 8<br/>
		/// will result in 9 (a 512-byte window).  In that case, providing 8 to<br/>
		/// inflateInit2() will result in an error when the zlib header with 9 is<br/>
		/// checked against the initialization of inflate().  The remedy is to not use 8<br/>
		/// with deflateInit2() with this initialization, or at least in that case use 9<br/>
		/// with inflateInit2().<br/>
		/// windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits<br/>
		/// determines the window size.  deflate() will then generate raw deflate data<br/>
		/// with no zlib header or trailer, and will not compute a check value.<br/>
		/// windowBits can also be greater than 15 for optional gzip encoding.  Add<br/>
		/// 16 to windowBits to write a simple gzip header and trailer around the<br/>
		/// compressed data instead of a zlib wrapper.  The gzip header will have no<br/>
		/// file name, no extra data, no comment, no modification time (set to zero), no<br/>
		/// header crc, and the operating system will be set to the appropriate value,<br/>
		/// if the operating system was determined at compile time.  If a gzip stream is<br/>
		/// being written, strm->adler is a CRC-32 instead of an Adler-32.<br/>
		/// For raw deflate or gzip encoding, a request for a 256-byte window is<br/>
		/// rejected as invalid, since only the zlib header provides a means of<br/>
		/// transmitting the window size to the decompressor.<br/>
		/// The memLevel parameter specifies how much memory should be allocated<br/>
		/// for the internal compression state.  memLevel=1 uses minimum memory but is<br/>
		/// slow and reduces compression ratio; memLevel=9 uses maximum memory for<br/>
		/// optimal speed.  The default value is 8.  See zconf.h for total memory usage<br/>
		/// as a function of windowBits and memLevel.<br/>
		/// The strategy parameter is used to tune the compression algorithm.  Use the<br/>
		/// value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a<br/>
		/// filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no<br/>
		/// string match), or Z_RLE to limit match distances to one (run-length<br/>
		/// encoding).  Filtered data consists mostly of small values with a somewhat<br/>
		/// random distribution.  In this case, the compression algorithm is tuned to<br/>
		/// compress them better.  The effect of Z_FILTERED is to force more Huffman<br/>
		/// coding and less string matching; it is somewhat intermediate between<br/>
		/// Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as<br/>
		/// fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The<br/>
		/// strategy parameter only affects the compression ratio but not the<br/>
		/// correctness of the compressed output even if it is not set appropriately.<br/>
		/// Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler<br/>
		/// decoder for special applications.<br/>
		/// deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid<br/>
		/// method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is<br/>
		/// incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is<br/>
		/// set to null if there is no error message.  deflateInit2 does not perform any<br/>
		/// compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateSetDictionary(ZStream* strm, ref byte dictionary, uint dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				int ret = DeflateSetDictionaryNative(strm, (byte*)pdictionary, dictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the compression dictionary from the given byte sequence<br/>
		/// without producing any compressed output.  When using the zlib format, this<br/>
		/// function must be called immediately after deflateInit, deflateInit2 or<br/>
		/// deflateReset, and before any call of deflate.  When doing raw deflate, this<br/>
		/// function must be called either before any call of deflate, or immediately<br/>
		/// after the completion of a deflate block, i.e. after all input has been<br/>
		/// consumed and all output has been delivered when using any of the flush<br/>
		/// options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The<br/>
		/// compressor and decompressor must use exactly the same dictionary (see<br/>
		/// inflateSetDictionary).<br/>
		/// The dictionary should consist of strings (byte sequences) that are likely<br/>
		/// to be encountered later in the data to be compressed, with the most commonly<br/>
		/// used strings preferably put towards the end of the dictionary.  Using a<br/>
		/// dictionary is most useful when the data to be compressed is short and can be<br/>
		/// predicted with good accuracy; the data can then be compressed better than<br/>
		/// with the default empty dictionary.<br/>
		/// Depending on the size of the compression data structures selected by<br/>
		/// deflateInit or deflateInit2, a part of the dictionary may in effect be<br/>
		/// discarded, for example if the dictionary is larger than the window size<br/>
		/// provided in deflateInit or deflateInit2.  Thus the strings most likely to be<br/>
		/// useful should be put at the end of the dictionary, not at the front.  In<br/>
		/// addition, the current implementation of deflate will use at most the window<br/>
		/// size minus 262 bytes of the provided dictionary.<br/>
		/// Upon return of this function, strm->adler is set to the Adler-32 value<br/>
		/// of the dictionary; the decompressor may later use this value to determine<br/>
		/// which dictionary has been used by the compressor.  (The Adler-32 value<br/>
		/// applies to the whole dictionary even if only a subset of the dictionary is<br/>
		/// actually used by the compressor.) If a raw deflate was requested, then the<br/>
		/// Adler-32 value is not computed and strm->adler is not set.<br/>
		/// deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent (for example if deflate has already been called for this stream<br/>
		/// or if not at a block boundary for raw deflate).  deflateSetDictionary does<br/>
		/// not perform any compression: this will be done by deflate().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateGetDictionaryNative(ZStream* strm, byte* dictionary, uint* dictLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, byte*, uint*, int>)funcTable[6])(strm, dictionary, dictLength);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[6])((nint)strm, (nint)dictionary, (nint)dictLength);
			#endif
		}

		/// <summary>
		/// Initializes the compression dictionary from the given byte sequence<br/>
		/// without producing any compressed output.  When using the zlib format, this<br/>
		/// function must be called immediately after deflateInit, deflateInit2 or<br/>
		/// deflateReset, and before any call of deflate.  When doing raw deflate, this<br/>
		/// function must be called either before any call of deflate, or immediately<br/>
		/// after the completion of a deflate block, i.e. after all input has been<br/>
		/// consumed and all output has been delivered when using any of the flush<br/>
		/// options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The<br/>
		/// compressor and decompressor must use exactly the same dictionary (see<br/>
		/// inflateSetDictionary).<br/>
		/// The dictionary should consist of strings (byte sequences) that are likely<br/>
		/// to be encountered later in the data to be compressed, with the most commonly<br/>
		/// used strings preferably put towards the end of the dictionary.  Using a<br/>
		/// dictionary is most useful when the data to be compressed is short and can be<br/>
		/// predicted with good accuracy; the data can then be compressed better than<br/>
		/// with the default empty dictionary.<br/>
		/// Depending on the size of the compression data structures selected by<br/>
		/// deflateInit or deflateInit2, a part of the dictionary may in effect be<br/>
		/// discarded, for example if the dictionary is larger than the window size<br/>
		/// provided in deflateInit or deflateInit2.  Thus the strings most likely to be<br/>
		/// useful should be put at the end of the dictionary, not at the front.  In<br/>
		/// addition, the current implementation of deflate will use at most the window<br/>
		/// size minus 262 bytes of the provided dictionary.<br/>
		/// Upon return of this function, strm->adler is set to the Adler-32 value<br/>
		/// of the dictionary; the decompressor may later use this value to determine<br/>
		/// which dictionary has been used by the compressor.  (The Adler-32 value<br/>
		/// applies to the whole dictionary even if only a subset of the dictionary is<br/>
		/// actually used by the compressor.) If a raw deflate was requested, then the<br/>
		/// Adler-32 value is not computed and strm->adler is not set.<br/>
		/// deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent (for example if deflate has already been called for this stream<br/>
		/// or if not at a block boundary for raw deflate).  deflateSetDictionary does<br/>
		/// not perform any compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateGetDictionary(ZStream* strm, byte* dictionary, uint* dictLength)
		{
			int ret = DeflateGetDictionaryNative(strm, dictionary, dictLength);
			return ret;
		}

		/// <summary>
		/// Initializes the compression dictionary from the given byte sequence<br/>
		/// without producing any compressed output.  When using the zlib format, this<br/>
		/// function must be called immediately after deflateInit, deflateInit2 or<br/>
		/// deflateReset, and before any call of deflate.  When doing raw deflate, this<br/>
		/// function must be called either before any call of deflate, or immediately<br/>
		/// after the completion of a deflate block, i.e. after all input has been<br/>
		/// consumed and all output has been delivered when using any of the flush<br/>
		/// options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The<br/>
		/// compressor and decompressor must use exactly the same dictionary (see<br/>
		/// inflateSetDictionary).<br/>
		/// The dictionary should consist of strings (byte sequences) that are likely<br/>
		/// to be encountered later in the data to be compressed, with the most commonly<br/>
		/// used strings preferably put towards the end of the dictionary.  Using a<br/>
		/// dictionary is most useful when the data to be compressed is short and can be<br/>
		/// predicted with good accuracy; the data can then be compressed better than<br/>
		/// with the default empty dictionary.<br/>
		/// Depending on the size of the compression data structures selected by<br/>
		/// deflateInit or deflateInit2, a part of the dictionary may in effect be<br/>
		/// discarded, for example if the dictionary is larger than the window size<br/>
		/// provided in deflateInit or deflateInit2.  Thus the strings most likely to be<br/>
		/// useful should be put at the end of the dictionary, not at the front.  In<br/>
		/// addition, the current implementation of deflate will use at most the window<br/>
		/// size minus 262 bytes of the provided dictionary.<br/>
		/// Upon return of this function, strm->adler is set to the Adler-32 value<br/>
		/// of the dictionary; the decompressor may later use this value to determine<br/>
		/// which dictionary has been used by the compressor.  (The Adler-32 value<br/>
		/// applies to the whole dictionary even if only a subset of the dictionary is<br/>
		/// actually used by the compressor.) If a raw deflate was requested, then the<br/>
		/// Adler-32 value is not computed and strm->adler is not set.<br/>
		/// deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent (for example if deflate has already been called for this stream<br/>
		/// or if not at a block boundary for raw deflate).  deflateSetDictionary does<br/>
		/// not perform any compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateGetDictionary(ZStream* strm, ref byte dictionary, uint* dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				int ret = DeflateGetDictionaryNative(strm, (byte*)pdictionary, dictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the compression dictionary from the given byte sequence<br/>
		/// without producing any compressed output.  When using the zlib format, this<br/>
		/// function must be called immediately after deflateInit, deflateInit2 or<br/>
		/// deflateReset, and before any call of deflate.  When doing raw deflate, this<br/>
		/// function must be called either before any call of deflate, or immediately<br/>
		/// after the completion of a deflate block, i.e. after all input has been<br/>
		/// consumed and all output has been delivered when using any of the flush<br/>
		/// options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The<br/>
		/// compressor and decompressor must use exactly the same dictionary (see<br/>
		/// inflateSetDictionary).<br/>
		/// The dictionary should consist of strings (byte sequences) that are likely<br/>
		/// to be encountered later in the data to be compressed, with the most commonly<br/>
		/// used strings preferably put towards the end of the dictionary.  Using a<br/>
		/// dictionary is most useful when the data to be compressed is short and can be<br/>
		/// predicted with good accuracy; the data can then be compressed better than<br/>
		/// with the default empty dictionary.<br/>
		/// Depending on the size of the compression data structures selected by<br/>
		/// deflateInit or deflateInit2, a part of the dictionary may in effect be<br/>
		/// discarded, for example if the dictionary is larger than the window size<br/>
		/// provided in deflateInit or deflateInit2.  Thus the strings most likely to be<br/>
		/// useful should be put at the end of the dictionary, not at the front.  In<br/>
		/// addition, the current implementation of deflate will use at most the window<br/>
		/// size minus 262 bytes of the provided dictionary.<br/>
		/// Upon return of this function, strm->adler is set to the Adler-32 value<br/>
		/// of the dictionary; the decompressor may later use this value to determine<br/>
		/// which dictionary has been used by the compressor.  (The Adler-32 value<br/>
		/// applies to the whole dictionary even if only a subset of the dictionary is<br/>
		/// actually used by the compressor.) If a raw deflate was requested, then the<br/>
		/// Adler-32 value is not computed and strm->adler is not set.<br/>
		/// deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent (for example if deflate has already been called for this stream<br/>
		/// or if not at a block boundary for raw deflate).  deflateSetDictionary does<br/>
		/// not perform any compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateGetDictionary(ZStream* strm, byte* dictionary, ref uint dictLength)
		{
			fixed (uint* pdictLength = &dictLength)
			{
				int ret = DeflateGetDictionaryNative(strm, dictionary, (uint*)pdictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the compression dictionary from the given byte sequence<br/>
		/// without producing any compressed output.  When using the zlib format, this<br/>
		/// function must be called immediately after deflateInit, deflateInit2 or<br/>
		/// deflateReset, and before any call of deflate.  When doing raw deflate, this<br/>
		/// function must be called either before any call of deflate, or immediately<br/>
		/// after the completion of a deflate block, i.e. after all input has been<br/>
		/// consumed and all output has been delivered when using any of the flush<br/>
		/// options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The<br/>
		/// compressor and decompressor must use exactly the same dictionary (see<br/>
		/// inflateSetDictionary).<br/>
		/// The dictionary should consist of strings (byte sequences) that are likely<br/>
		/// to be encountered later in the data to be compressed, with the most commonly<br/>
		/// used strings preferably put towards the end of the dictionary.  Using a<br/>
		/// dictionary is most useful when the data to be compressed is short and can be<br/>
		/// predicted with good accuracy; the data can then be compressed better than<br/>
		/// with the default empty dictionary.<br/>
		/// Depending on the size of the compression data structures selected by<br/>
		/// deflateInit or deflateInit2, a part of the dictionary may in effect be<br/>
		/// discarded, for example if the dictionary is larger than the window size<br/>
		/// provided in deflateInit or deflateInit2.  Thus the strings most likely to be<br/>
		/// useful should be put at the end of the dictionary, not at the front.  In<br/>
		/// addition, the current implementation of deflate will use at most the window<br/>
		/// size minus 262 bytes of the provided dictionary.<br/>
		/// Upon return of this function, strm->adler is set to the Adler-32 value<br/>
		/// of the dictionary; the decompressor may later use this value to determine<br/>
		/// which dictionary has been used by the compressor.  (The Adler-32 value<br/>
		/// applies to the whole dictionary even if only a subset of the dictionary is<br/>
		/// actually used by the compressor.) If a raw deflate was requested, then the<br/>
		/// Adler-32 value is not computed and strm->adler is not set.<br/>
		/// deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent (for example if deflate has already been called for this stream<br/>
		/// or if not at a block boundary for raw deflate).  deflateSetDictionary does<br/>
		/// not perform any compression: this will be done by deflate().<br/>
		/// </summary>
		public static int DeflateGetDictionary(ZStream* strm, ref byte dictionary, ref uint dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				fixed (uint* pdictLength = &dictLength)
				{
					int ret = DeflateGetDictionaryNative(strm, (byte*)pdictionary, (uint*)pdictLength);
					return ret;
				}
			}
		}

		/// <summary>
		/// Returns the sliding dictionary being maintained by deflate.  dictLength is<br/>
		/// set to the number of bytes in the dictionary, and that many bytes are copied<br/>
		/// to dictionary.  dictionary must have enough space, where 32768 bytes is<br/>
		/// always enough.  If deflateGetDictionary() is called with dictionary equal to<br/>
		/// Z_NULL, then only the dictionary length is returned, and nothing is copied.<br/>
		/// Similarly, if dictLength is Z_NULL, then it is not set.<br/>
		/// deflateGetDictionary() may return a length less than the window size, even<br/>
		/// when more than the window size in input has been provided. It may return up<br/>
		/// to 258 bytes less in that case, due to how zlib's implementation of deflate<br/>
		/// manages the sliding window and lookahead for matches, where matches can be<br/>
		/// up to 258 bytes long. If the application needs the last window-size bytes of<br/>
		/// input, then that would need to be saved by the application outside of zlib.<br/>
		/// deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the<br/>
		/// stream state is inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateCopyNative(ZStream* dest, ZStream* source)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, ZStream*, int>)funcTable[7])(dest, source);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[7])((nint)dest, (nint)source);
			#endif
		}

		/// <summary>
		/// Returns the sliding dictionary being maintained by deflate.  dictLength is<br/>
		/// set to the number of bytes in the dictionary, and that many bytes are copied<br/>
		/// to dictionary.  dictionary must have enough space, where 32768 bytes is<br/>
		/// always enough.  If deflateGetDictionary() is called with dictionary equal to<br/>
		/// Z_NULL, then only the dictionary length is returned, and nothing is copied.<br/>
		/// Similarly, if dictLength is Z_NULL, then it is not set.<br/>
		/// deflateGetDictionary() may return a length less than the window size, even<br/>
		/// when more than the window size in input has been provided. It may return up<br/>
		/// to 258 bytes less in that case, due to how zlib's implementation of deflate<br/>
		/// manages the sliding window and lookahead for matches, where matches can be<br/>
		/// up to 258 bytes long. If the application needs the last window-size bytes of<br/>
		/// input, then that would need to be saved by the application outside of zlib.<br/>
		/// deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the<br/>
		/// stream state is inconsistent.<br/>
		/// </summary>
		public static int DeflateCopy(ZStream* dest, ZStream* source)
		{
			int ret = DeflateCopyNative(dest, source);
			return ret;
		}

		/// <summary>
		/// Sets the destination stream as a complete copy of the source stream.<br/>
		/// This function can be useful when several compression strategies will be<br/>
		/// tried, for example when there are several ways of pre-processing the input<br/>
		/// data with a filter.  The streams that will be discarded should then be freed<br/>
		/// by calling deflateEnd.  Note that deflateCopy duplicates the internal<br/>
		/// compression state which can be quite large, so this strategy is slow and can<br/>
		/// consume lots of memory.<br/>
		/// deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_STREAM_ERROR if the source stream state was inconsistent<br/>
		/// (such as zalloc being Z_NULL).  msg is left unchanged in both source and<br/>
		/// destination.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateResetNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[8])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[8])((nint)strm);
			#endif
		}

		/// <summary>
		/// Sets the destination stream as a complete copy of the source stream.<br/>
		/// This function can be useful when several compression strategies will be<br/>
		/// tried, for example when there are several ways of pre-processing the input<br/>
		/// data with a filter.  The streams that will be discarded should then be freed<br/>
		/// by calling deflateEnd.  Note that deflateCopy duplicates the internal<br/>
		/// compression state which can be quite large, so this strategy is slow and can<br/>
		/// consume lots of memory.<br/>
		/// deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_STREAM_ERROR if the source stream state was inconsistent<br/>
		/// (such as zalloc being Z_NULL).  msg is left unchanged in both source and<br/>
		/// destination.<br/>
		/// </summary>
		public static int DeflateReset(ZStream* strm)
		{
			int ret = DeflateResetNative(strm);
			return ret;
		}

		/// <summary>
		/// This function is equivalent to deflateEnd followed by deflateInit, but<br/>
		/// does not free and reallocate the internal compression state.  The stream<br/>
		/// will leave the compression level and any other attributes that may have been<br/>
		/// set unchanged.  total_in, total_out, adler, and msg are initialized.<br/>
		/// deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateParamsNative(ZStream* strm, int level, int strategy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int, int>)funcTable[9])(strm, level, strategy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)funcTable[9])((nint)strm, level, strategy);
			#endif
		}

		/// <summary>
		/// This function is equivalent to deflateEnd followed by deflateInit, but<br/>
		/// does not free and reallocate the internal compression state.  The stream<br/>
		/// will leave the compression level and any other attributes that may have been<br/>
		/// set unchanged.  total_in, total_out, adler, and msg are initialized.<br/>
		/// deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL).<br/>
		/// </summary>
		public static int DeflateParams(ZStream* strm, int level, int strategy)
		{
			int ret = DeflateParamsNative(strm, level, strategy);
			return ret;
		}

		/// <summary>
		/// Dynamically update the compression level and compression strategy.  The<br/>
		/// interpretation of level and strategy is as in deflateInit2().  This can be<br/>
		/// used to switch between compression and straight copy of the input data, or<br/>
		/// to switch to a different kind of input data requiring a different strategy.<br/>
		/// If the compression approach (which is a function of the level) or the<br/>
		/// strategy is changed, and if there have been any deflate() calls since the<br/>
		/// state was initialized or reset, then the input available so far is<br/>
		/// compressed with the old level and strategy using deflate(strm, Z_BLOCK).<br/>
		/// There are three approaches for the compression levels 0, 1..3, and 4..9<br/>
		/// respectively.  The new level and strategy will take effect at the next call<br/>
		/// of deflate().<br/>
		/// If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does<br/>
		/// not have enough output space to complete, then the parameter change will not<br/>
		/// take effect.  In this case, deflateParams() can be called again with the<br/>
		/// same parameters and more output space to try again.<br/>
		/// In order to assure a change in the parameters on the first try, the<br/>
		/// deflate stream should be flushed using deflate() with Z_BLOCK or other flush<br/>
		/// request until strm.avail_out is not zero, before calling deflateParams().<br/>
		/// Then no more input data should be provided before the deflateParams() call.<br/>
		/// If this is done, the old level and strategy will be applied to the data<br/>
		/// compressed before deflateParams(), and the new level and strategy will be<br/>
		/// applied to the data compressed after deflateParams().<br/>
		/// deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream<br/>
		/// state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if<br/>
		/// there was not enough output space to complete the compression of the<br/>
		/// available input data before a change in the strategy or approach.  Note that<br/>
		/// in the case of a Z_BUF_ERROR, the parameters are not changed.  A return<br/>
		/// value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be<br/>
		/// retried with more output space.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateTuneNative(ZStream* strm, int goodLength, int maxLazy, int niceLength, int maxChain)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int, int, int, int>)funcTable[10])(strm, goodLength, maxLazy, niceLength, maxChain);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, int>)funcTable[10])((nint)strm, goodLength, maxLazy, niceLength, maxChain);
			#endif
		}

		/// <summary>
		/// Dynamically update the compression level and compression strategy.  The<br/>
		/// interpretation of level and strategy is as in deflateInit2().  This can be<br/>
		/// used to switch between compression and straight copy of the input data, or<br/>
		/// to switch to a different kind of input data requiring a different strategy.<br/>
		/// If the compression approach (which is a function of the level) or the<br/>
		/// strategy is changed, and if there have been any deflate() calls since the<br/>
		/// state was initialized or reset, then the input available so far is<br/>
		/// compressed with the old level and strategy using deflate(strm, Z_BLOCK).<br/>
		/// There are three approaches for the compression levels 0, 1..3, and 4..9<br/>
		/// respectively.  The new level and strategy will take effect at the next call<br/>
		/// of deflate().<br/>
		/// If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does<br/>
		/// not have enough output space to complete, then the parameter change will not<br/>
		/// take effect.  In this case, deflateParams() can be called again with the<br/>
		/// same parameters and more output space to try again.<br/>
		/// In order to assure a change in the parameters on the first try, the<br/>
		/// deflate stream should be flushed using deflate() with Z_BLOCK or other flush<br/>
		/// request until strm.avail_out is not zero, before calling deflateParams().<br/>
		/// Then no more input data should be provided before the deflateParams() call.<br/>
		/// If this is done, the old level and strategy will be applied to the data<br/>
		/// compressed before deflateParams(), and the new level and strategy will be<br/>
		/// applied to the data compressed after deflateParams().<br/>
		/// deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream<br/>
		/// state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if<br/>
		/// there was not enough output space to complete the compression of the<br/>
		/// available input data before a change in the strategy or approach.  Note that<br/>
		/// in the case of a Z_BUF_ERROR, the parameters are not changed.  A return<br/>
		/// value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be<br/>
		/// retried with more output space.<br/>
		/// </summary>
		public static int DeflateTune(ZStream* strm, int goodLength, int maxLazy, int niceLength, int maxChain)
		{
			int ret = DeflateTuneNative(strm, goodLength, maxLazy, niceLength, maxChain);
			return ret;
		}

		/// <summary>
		/// Fine tune deflate's internal compression parameters.  This should only be<br/>
		/// used by someone who understands the algorithm used by zlib's deflate for<br/>
		/// searching for the best matching string, and even then only by the most<br/>
		/// fanatic optimizer trying to squeeze out the last compressed bit for their<br/>
		/// specific input data.  Read the deflate.c source code for the meaning of the<br/>
		/// max_lazy, good_length, nice_length, and max_chain parameters.<br/>
		/// deflateTune() can be called after deflateInit() or deflateInit2(), and<br/>
		/// returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint DeflateBoundNative(ZStream* strm, uint sourceLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, uint, uint>)funcTable[11])(strm, sourceLen);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint, uint>)funcTable[11])((nint)strm, sourceLen);
			#endif
		}

		/// <summary>
		/// Fine tune deflate's internal compression parameters.  This should only be<br/>
		/// used by someone who understands the algorithm used by zlib's deflate for<br/>
		/// searching for the best matching string, and even then only by the most<br/>
		/// fanatic optimizer trying to squeeze out the last compressed bit for their<br/>
		/// specific input data.  Read the deflate.c source code for the meaning of the<br/>
		/// max_lazy, good_length, nice_length, and max_chain parameters.<br/>
		/// deflateTune() can be called after deflateInit() or deflateInit2(), and<br/>
		/// returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.<br/>
		/// </summary>
		public static uint DeflateBound(ZStream* strm, uint sourceLen)
		{
			uint ret = DeflateBoundNative(strm, sourceLen);
			return ret;
		}

		/// <summary>
		/// deflateBound() returns an upper bound on the compressed size after<br/>
		/// deflation of sourceLen bytes.  It must be called after deflateInit() or<br/>
		/// deflateInit2(), and after deflateSetHeader(), if used.  This would be used<br/>
		/// to allocate an output buffer for deflation in a single pass, and so would be<br/>
		/// called before deflate().  If that first deflate() call is provided the<br/>
		/// sourceLen input bytes, an output buffer allocated to the size returned by<br/>
		/// deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed<br/>
		/// to return Z_STREAM_END.  Note that it is possible for the compressed size to<br/>
		/// be larger than the value returned by deflateBound() if flush options other<br/>
		/// than Z_FINISH or Z_NO_FLUSH are used.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflatePendingNative(ZStream* strm, uint* pending, int* bits)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, uint*, int*, int>)funcTable[12])(strm, pending, bits);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[12])((nint)strm, (nint)pending, (nint)bits);
			#endif
		}

		/// <summary>
		/// deflateBound() returns an upper bound on the compressed size after<br/>
		/// deflation of sourceLen bytes.  It must be called after deflateInit() or<br/>
		/// deflateInit2(), and after deflateSetHeader(), if used.  This would be used<br/>
		/// to allocate an output buffer for deflation in a single pass, and so would be<br/>
		/// called before deflate().  If that first deflate() call is provided the<br/>
		/// sourceLen input bytes, an output buffer allocated to the size returned by<br/>
		/// deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed<br/>
		/// to return Z_STREAM_END.  Note that it is possible for the compressed size to<br/>
		/// be larger than the value returned by deflateBound() if flush options other<br/>
		/// than Z_FINISH or Z_NO_FLUSH are used.<br/>
		/// </summary>
		public static int DeflatePending(ZStream* strm, uint* pending, int* bits)
		{
			int ret = DeflatePendingNative(strm, pending, bits);
			return ret;
		}

		/// <summary>
		/// deflateBound() returns an upper bound on the compressed size after<br/>
		/// deflation of sourceLen bytes.  It must be called after deflateInit() or<br/>
		/// deflateInit2(), and after deflateSetHeader(), if used.  This would be used<br/>
		/// to allocate an output buffer for deflation in a single pass, and so would be<br/>
		/// called before deflate().  If that first deflate() call is provided the<br/>
		/// sourceLen input bytes, an output buffer allocated to the size returned by<br/>
		/// deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed<br/>
		/// to return Z_STREAM_END.  Note that it is possible for the compressed size to<br/>
		/// be larger than the value returned by deflateBound() if flush options other<br/>
		/// than Z_FINISH or Z_NO_FLUSH are used.<br/>
		/// </summary>
		public static int DeflatePending(ZStream* strm, ref uint pending, int* bits)
		{
			fixed (uint* ppending = &pending)
			{
				int ret = DeflatePendingNative(strm, (uint*)ppending, bits);
				return ret;
			}
		}

		/// <summary>
		/// deflateBound() returns an upper bound on the compressed size after<br/>
		/// deflation of sourceLen bytes.  It must be called after deflateInit() or<br/>
		/// deflateInit2(), and after deflateSetHeader(), if used.  This would be used<br/>
		/// to allocate an output buffer for deflation in a single pass, and so would be<br/>
		/// called before deflate().  If that first deflate() call is provided the<br/>
		/// sourceLen input bytes, an output buffer allocated to the size returned by<br/>
		/// deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed<br/>
		/// to return Z_STREAM_END.  Note that it is possible for the compressed size to<br/>
		/// be larger than the value returned by deflateBound() if flush options other<br/>
		/// than Z_FINISH or Z_NO_FLUSH are used.<br/>
		/// </summary>
		public static int DeflatePending(ZStream* strm, uint* pending, ref int bits)
		{
			fixed (int* pbits = &bits)
			{
				int ret = DeflatePendingNative(strm, pending, (int*)pbits);
				return ret;
			}
		}

		/// <summary>
		/// deflateBound() returns an upper bound on the compressed size after<br/>
		/// deflation of sourceLen bytes.  It must be called after deflateInit() or<br/>
		/// deflateInit2(), and after deflateSetHeader(), if used.  This would be used<br/>
		/// to allocate an output buffer for deflation in a single pass, and so would be<br/>
		/// called before deflate().  If that first deflate() call is provided the<br/>
		/// sourceLen input bytes, an output buffer allocated to the size returned by<br/>
		/// deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed<br/>
		/// to return Z_STREAM_END.  Note that it is possible for the compressed size to<br/>
		/// be larger than the value returned by deflateBound() if flush options other<br/>
		/// than Z_FINISH or Z_NO_FLUSH are used.<br/>
		/// </summary>
		public static int DeflatePending(ZStream* strm, ref uint pending, ref int bits)
		{
			fixed (uint* ppending = &pending)
			{
				fixed (int* pbits = &bits)
				{
					int ret = DeflatePendingNative(strm, (uint*)ppending, (int*)pbits);
					return ret;
				}
			}
		}

		/// <summary>
		/// deflatePending() returns the number of bytes and bits of output that have<br/>
		/// been generated, but not yet provided in the available output.  The bytes not<br/>
		/// provided would be due to the available output space having being consumed.<br/>
		/// The number of bits of output not provided are between 0 and 7, where they<br/>
		/// await more bits to join them in order to fill out a full byte.  If pending<br/>
		/// or bits are Z_NULL, then those values are not set.<br/>
		/// deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflatePrimeNative(ZStream* strm, int bits, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int, int>)funcTable[13])(strm, bits, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)funcTable[13])((nint)strm, bits, value);
			#endif
		}

		/// <summary>
		/// deflatePending() returns the number of bytes and bits of output that have<br/>
		/// been generated, but not yet provided in the available output.  The bytes not<br/>
		/// provided would be due to the available output space having being consumed.<br/>
		/// The number of bits of output not provided are between 0 and 7, where they<br/>
		/// await more bits to join them in order to fill out a full byte.  If pending<br/>
		/// or bits are Z_NULL, then those values are not set.<br/>
		/// deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent.<br/>
		/// </summary>
		public static int DeflatePrime(ZStream* strm, int bits, int value)
		{
			int ret = DeflatePrimeNative(strm, bits, value);
			return ret;
		}

		/// <summary>
		/// deflatePrime() inserts bits in the deflate output stream.  The intent<br/>
		/// is that this function is used to start off the deflate output with the bits<br/>
		/// leftover from a previous deflate stream when appending to it.  As such, this<br/>
		/// function can only be used for raw deflate, and must be used before the first<br/>
		/// deflate() call after a deflateInit2() or deflateReset().  bits must be less<br/>
		/// than or equal to 16, and that many of the least significant bits of value<br/>
		/// will be inserted in the output.<br/>
		/// deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough<br/>
		/// room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the<br/>
		/// source stream state was inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateSetHeaderNative(ZStream* strm, GZHeader* head)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, GZHeader*, int>)funcTable[14])(strm, head);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[14])((nint)strm, (nint)head);
			#endif
		}

		/// <summary>
		/// deflatePrime() inserts bits in the deflate output stream.  The intent<br/>
		/// is that this function is used to start off the deflate output with the bits<br/>
		/// leftover from a previous deflate stream when appending to it.  As such, this<br/>
		/// function can only be used for raw deflate, and must be used before the first<br/>
		/// deflate() call after a deflateInit2() or deflateReset().  bits must be less<br/>
		/// than or equal to 16, and that many of the least significant bits of value<br/>
		/// will be inserted in the output.<br/>
		/// deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough<br/>
		/// room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the<br/>
		/// source stream state was inconsistent.<br/>
		/// </summary>
		public static int DeflateSetHeader(ZStream* strm, GZHeader* head)
		{
			int ret = DeflateSetHeaderNative(strm, head);
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,<br/>
		/// int windowBits);<br/>
		/// This is another version of inflateInit with an extra parameter.  The<br/>
		/// fields next_in, avail_in, zalloc, zfree and opaque must be initialized<br/>
		/// before by the caller.<br/>
		/// The windowBits parameter is the base two logarithm of the maximum window<br/>
		/// size (the size of the history buffer).  It should be in the range 8..15 for<br/>
		/// this version of the library.  The default value is 15 if inflateInit is used<br/>
		/// instead.  windowBits must be greater than or equal to the windowBits value<br/>
		/// provided to deflateInit2() while compressing, or it must be equal to 15 if<br/>
		/// deflateInit2() was not used.  If a compressed stream with a larger window<br/>
		/// size is given as input, inflate() will return with the error code<br/>
		/// Z_DATA_ERROR instead of trying to allocate a larger window.<br/>
		/// windowBits can also be zero to request that inflate use the window size in<br/>
		/// the zlib header of the compressed stream.<br/>
		/// windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits<br/>
		/// determines the window size.  inflate() will then process raw deflate data,<br/>
		/// not looking for a zlib or gzip header, not generating a check value, and not<br/>
		/// looking for any check values for comparison at the end of the stream.  This<br/>
		/// is for use with other formats that use the deflate compressed data format<br/>
		/// such as zip.  Those formats provide their own check values.  If a custom<br/>
		/// format is developed using the raw deflate format for compressed data, it is<br/>
		/// recommended that a check value such as an Adler-32 or a CRC-32 be applied to<br/>
		/// the uncompressed data as is done in the zlib, gzip, and zip formats.  For<br/>
		/// most applications, the zlib format should be used as is.  Note that comments<br/>
		/// above on the use in deflateInit2() applies to the magnitude of windowBits.<br/>
		/// windowBits can also be greater than 15 for optional gzip decoding.  Add<br/>
		/// 32 to windowBits to enable zlib and gzip decoding with automatic header<br/>
		/// detection, or add 16 to decode only the gzip format (the zlib format will<br/>
		/// return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a<br/>
		/// CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see<br/>
		/// below), inflate() will *not* automatically decode concatenated gzip members.<br/>
		/// inflate() will return Z_STREAM_END at the end of the gzip member.  The state<br/>
		/// would need to be reset to continue decoding a subsequent gzip member.  This<br/>
		/// must* be done if there is more data after a gzip member, in order for the<br/>
		/// decompression to be compliant with the gzip standard (RFC 1952).<br/>
		/// inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_VERSION_ERROR if the zlib library version is incompatible with the<br/>
		/// version assumed by the caller, or Z_STREAM_ERROR if the parameters are<br/>
		/// invalid, such as a null pointer to the structure.  msg is set to null if<br/>
		/// there is no error message.  inflateInit2 does not perform any decompression<br/>
		/// apart from possibly reading the zlib header if present: actual decompression<br/>
		/// will be done by inflate().  (So next_in and avail_in may be modified, but<br/>
		/// next_out and avail_out are unused and unchanged.) The current implementation<br/>
		/// of inflateInit2() does not process any header information -- that is<br/>
		/// deferred until inflate() is called.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateSetDictionaryNative(ZStream* strm, byte* dictionary, uint dictLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, byte*, uint, int>)funcTable[15])(strm, dictionary, dictLength);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, uint, int>)funcTable[15])((nint)strm, (nint)dictionary, dictLength);
			#endif
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,<br/>
		/// int windowBits);<br/>
		/// This is another version of inflateInit with an extra parameter.  The<br/>
		/// fields next_in, avail_in, zalloc, zfree and opaque must be initialized<br/>
		/// before by the caller.<br/>
		/// The windowBits parameter is the base two logarithm of the maximum window<br/>
		/// size (the size of the history buffer).  It should be in the range 8..15 for<br/>
		/// this version of the library.  The default value is 15 if inflateInit is used<br/>
		/// instead.  windowBits must be greater than or equal to the windowBits value<br/>
		/// provided to deflateInit2() while compressing, or it must be equal to 15 if<br/>
		/// deflateInit2() was not used.  If a compressed stream with a larger window<br/>
		/// size is given as input, inflate() will return with the error code<br/>
		/// Z_DATA_ERROR instead of trying to allocate a larger window.<br/>
		/// windowBits can also be zero to request that inflate use the window size in<br/>
		/// the zlib header of the compressed stream.<br/>
		/// windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits<br/>
		/// determines the window size.  inflate() will then process raw deflate data,<br/>
		/// not looking for a zlib or gzip header, not generating a check value, and not<br/>
		/// looking for any check values for comparison at the end of the stream.  This<br/>
		/// is for use with other formats that use the deflate compressed data format<br/>
		/// such as zip.  Those formats provide their own check values.  If a custom<br/>
		/// format is developed using the raw deflate format for compressed data, it is<br/>
		/// recommended that a check value such as an Adler-32 or a CRC-32 be applied to<br/>
		/// the uncompressed data as is done in the zlib, gzip, and zip formats.  For<br/>
		/// most applications, the zlib format should be used as is.  Note that comments<br/>
		/// above on the use in deflateInit2() applies to the magnitude of windowBits.<br/>
		/// windowBits can also be greater than 15 for optional gzip decoding.  Add<br/>
		/// 32 to windowBits to enable zlib and gzip decoding with automatic header<br/>
		/// detection, or add 16 to decode only the gzip format (the zlib format will<br/>
		/// return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a<br/>
		/// CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see<br/>
		/// below), inflate() will *not* automatically decode concatenated gzip members.<br/>
		/// inflate() will return Z_STREAM_END at the end of the gzip member.  The state<br/>
		/// would need to be reset to continue decoding a subsequent gzip member.  This<br/>
		/// must* be done if there is more data after a gzip member, in order for the<br/>
		/// decompression to be compliant with the gzip standard (RFC 1952).<br/>
		/// inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_VERSION_ERROR if the zlib library version is incompatible with the<br/>
		/// version assumed by the caller, or Z_STREAM_ERROR if the parameters are<br/>
		/// invalid, such as a null pointer to the structure.  msg is set to null if<br/>
		/// there is no error message.  inflateInit2 does not perform any decompression<br/>
		/// apart from possibly reading the zlib header if present: actual decompression<br/>
		/// will be done by inflate().  (So next_in and avail_in may be modified, but<br/>
		/// next_out and avail_out are unused and unchanged.) The current implementation<br/>
		/// of inflateInit2() does not process any header information -- that is<br/>
		/// deferred until inflate() is called.<br/>
		/// </summary>
		public static int InflateSetDictionary(ZStream* strm, byte* dictionary, uint dictLength)
		{
			int ret = InflateSetDictionaryNative(strm, dictionary, dictLength);
			return ret;
		}

		/// <summary>
		/// ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,<br/>
		/// int windowBits);<br/>
		/// This is another version of inflateInit with an extra parameter.  The<br/>
		/// fields next_in, avail_in, zalloc, zfree and opaque must be initialized<br/>
		/// before by the caller.<br/>
		/// The windowBits parameter is the base two logarithm of the maximum window<br/>
		/// size (the size of the history buffer).  It should be in the range 8..15 for<br/>
		/// this version of the library.  The default value is 15 if inflateInit is used<br/>
		/// instead.  windowBits must be greater than or equal to the windowBits value<br/>
		/// provided to deflateInit2() while compressing, or it must be equal to 15 if<br/>
		/// deflateInit2() was not used.  If a compressed stream with a larger window<br/>
		/// size is given as input, inflate() will return with the error code<br/>
		/// Z_DATA_ERROR instead of trying to allocate a larger window.<br/>
		/// windowBits can also be zero to request that inflate use the window size in<br/>
		/// the zlib header of the compressed stream.<br/>
		/// windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits<br/>
		/// determines the window size.  inflate() will then process raw deflate data,<br/>
		/// not looking for a zlib or gzip header, not generating a check value, and not<br/>
		/// looking for any check values for comparison at the end of the stream.  This<br/>
		/// is for use with other formats that use the deflate compressed data format<br/>
		/// such as zip.  Those formats provide their own check values.  If a custom<br/>
		/// format is developed using the raw deflate format for compressed data, it is<br/>
		/// recommended that a check value such as an Adler-32 or a CRC-32 be applied to<br/>
		/// the uncompressed data as is done in the zlib, gzip, and zip formats.  For<br/>
		/// most applications, the zlib format should be used as is.  Note that comments<br/>
		/// above on the use in deflateInit2() applies to the magnitude of windowBits.<br/>
		/// windowBits can also be greater than 15 for optional gzip decoding.  Add<br/>
		/// 32 to windowBits to enable zlib and gzip decoding with automatic header<br/>
		/// detection, or add 16 to decode only the gzip format (the zlib format will<br/>
		/// return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a<br/>
		/// CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see<br/>
		/// below), inflate() will *not* automatically decode concatenated gzip members.<br/>
		/// inflate() will return Z_STREAM_END at the end of the gzip member.  The state<br/>
		/// would need to be reset to continue decoding a subsequent gzip member.  This<br/>
		/// must* be done if there is more data after a gzip member, in order for the<br/>
		/// decompression to be compliant with the gzip standard (RFC 1952).<br/>
		/// inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_VERSION_ERROR if the zlib library version is incompatible with the<br/>
		/// version assumed by the caller, or Z_STREAM_ERROR if the parameters are<br/>
		/// invalid, such as a null pointer to the structure.  msg is set to null if<br/>
		/// there is no error message.  inflateInit2 does not perform any decompression<br/>
		/// apart from possibly reading the zlib header if present: actual decompression<br/>
		/// will be done by inflate().  (So next_in and avail_in may be modified, but<br/>
		/// next_out and avail_out are unused and unchanged.) The current implementation<br/>
		/// of inflateInit2() does not process any header information -- that is<br/>
		/// deferred until inflate() is called.<br/>
		/// </summary>
		public static int InflateSetDictionary(ZStream* strm, ref byte dictionary, uint dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				int ret = InflateSetDictionaryNative(strm, (byte*)pdictionary, dictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the decompression dictionary from the given uncompressed byte<br/>
		/// sequence.  This function must be called immediately after a call of inflate,<br/>
		/// if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor<br/>
		/// can be determined from the Adler-32 value returned by that call of inflate.<br/>
		/// The compressor and decompressor must use exactly the same dictionary (see<br/>
		/// deflateSetDictionary).  For raw inflate, this function can be called at any<br/>
		/// time to set the dictionary.  If the provided dictionary is smaller than the<br/>
		/// window and there is already data in the window, then the provided dictionary<br/>
		/// will amend what's there.  The application must insure that the dictionary<br/>
		/// that was used for compression is provided.<br/>
		/// inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the<br/>
		/// expected one (incorrect Adler-32 value).  inflateSetDictionary does not<br/>
		/// perform any decompression: this will be done by subsequent calls of<br/>
		/// inflate().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateGetDictionaryNative(ZStream* strm, byte* dictionary, uint* dictLength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, byte*, uint*, int>)funcTable[16])(strm, dictionary, dictLength);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[16])((nint)strm, (nint)dictionary, (nint)dictLength);
			#endif
		}

		/// <summary>
		/// Initializes the decompression dictionary from the given uncompressed byte<br/>
		/// sequence.  This function must be called immediately after a call of inflate,<br/>
		/// if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor<br/>
		/// can be determined from the Adler-32 value returned by that call of inflate.<br/>
		/// The compressor and decompressor must use exactly the same dictionary (see<br/>
		/// deflateSetDictionary).  For raw inflate, this function can be called at any<br/>
		/// time to set the dictionary.  If the provided dictionary is smaller than the<br/>
		/// window and there is already data in the window, then the provided dictionary<br/>
		/// will amend what's there.  The application must insure that the dictionary<br/>
		/// that was used for compression is provided.<br/>
		/// inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the<br/>
		/// expected one (incorrect Adler-32 value).  inflateSetDictionary does not<br/>
		/// perform any decompression: this will be done by subsequent calls of<br/>
		/// inflate().<br/>
		/// </summary>
		public static int InflateGetDictionary(ZStream* strm, byte* dictionary, uint* dictLength)
		{
			int ret = InflateGetDictionaryNative(strm, dictionary, dictLength);
			return ret;
		}

		/// <summary>
		/// Initializes the decompression dictionary from the given uncompressed byte<br/>
		/// sequence.  This function must be called immediately after a call of inflate,<br/>
		/// if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor<br/>
		/// can be determined from the Adler-32 value returned by that call of inflate.<br/>
		/// The compressor and decompressor must use exactly the same dictionary (see<br/>
		/// deflateSetDictionary).  For raw inflate, this function can be called at any<br/>
		/// time to set the dictionary.  If the provided dictionary is smaller than the<br/>
		/// window and there is already data in the window, then the provided dictionary<br/>
		/// will amend what's there.  The application must insure that the dictionary<br/>
		/// that was used for compression is provided.<br/>
		/// inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the<br/>
		/// expected one (incorrect Adler-32 value).  inflateSetDictionary does not<br/>
		/// perform any decompression: this will be done by subsequent calls of<br/>
		/// inflate().<br/>
		/// </summary>
		public static int InflateGetDictionary(ZStream* strm, ref byte dictionary, uint* dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				int ret = InflateGetDictionaryNative(strm, (byte*)pdictionary, dictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the decompression dictionary from the given uncompressed byte<br/>
		/// sequence.  This function must be called immediately after a call of inflate,<br/>
		/// if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor<br/>
		/// can be determined from the Adler-32 value returned by that call of inflate.<br/>
		/// The compressor and decompressor must use exactly the same dictionary (see<br/>
		/// deflateSetDictionary).  For raw inflate, this function can be called at any<br/>
		/// time to set the dictionary.  If the provided dictionary is smaller than the<br/>
		/// window and there is already data in the window, then the provided dictionary<br/>
		/// will amend what's there.  The application must insure that the dictionary<br/>
		/// that was used for compression is provided.<br/>
		/// inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the<br/>
		/// expected one (incorrect Adler-32 value).  inflateSetDictionary does not<br/>
		/// perform any decompression: this will be done by subsequent calls of<br/>
		/// inflate().<br/>
		/// </summary>
		public static int InflateGetDictionary(ZStream* strm, byte* dictionary, ref uint dictLength)
		{
			fixed (uint* pdictLength = &dictLength)
			{
				int ret = InflateGetDictionaryNative(strm, dictionary, (uint*)pdictLength);
				return ret;
			}
		}

		/// <summary>
		/// Initializes the decompression dictionary from the given uncompressed byte<br/>
		/// sequence.  This function must be called immediately after a call of inflate,<br/>
		/// if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor<br/>
		/// can be determined from the Adler-32 value returned by that call of inflate.<br/>
		/// The compressor and decompressor must use exactly the same dictionary (see<br/>
		/// deflateSetDictionary).  For raw inflate, this function can be called at any<br/>
		/// time to set the dictionary.  If the provided dictionary is smaller than the<br/>
		/// window and there is already data in the window, then the provided dictionary<br/>
		/// will amend what's there.  The application must insure that the dictionary<br/>
		/// that was used for compression is provided.<br/>
		/// inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a<br/>
		/// parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is<br/>
		/// inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the<br/>
		/// expected one (incorrect Adler-32 value).  inflateSetDictionary does not<br/>
		/// perform any decompression: this will be done by subsequent calls of<br/>
		/// inflate().<br/>
		/// </summary>
		public static int InflateGetDictionary(ZStream* strm, ref byte dictionary, ref uint dictLength)
		{
			fixed (byte* pdictionary = &dictionary)
			{
				fixed (uint* pdictLength = &dictLength)
				{
					int ret = InflateGetDictionaryNative(strm, (byte*)pdictionary, (uint*)pdictLength);
					return ret;
				}
			}
		}

		/// <summary>
		/// Returns the sliding dictionary being maintained by inflate.  dictLength is<br/>
		/// set to the number of bytes in the dictionary, and that many bytes are copied<br/>
		/// to dictionary.  dictionary must have enough space, where 32768 bytes is<br/>
		/// always enough.  If inflateGetDictionary() is called with dictionary equal to<br/>
		/// Z_NULL, then only the dictionary length is returned, and nothing is copied.<br/>
		/// Similarly, if dictLength is Z_NULL, then it is not set.<br/>
		/// inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the<br/>
		/// stream state is inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateSyncNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[17])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[17])((nint)strm);
			#endif
		}

		/// <summary>
		/// Returns the sliding dictionary being maintained by inflate.  dictLength is<br/>
		/// set to the number of bytes in the dictionary, and that many bytes are copied<br/>
		/// to dictionary.  dictionary must have enough space, where 32768 bytes is<br/>
		/// always enough.  If inflateGetDictionary() is called with dictionary equal to<br/>
		/// Z_NULL, then only the dictionary length is returned, and nothing is copied.<br/>
		/// Similarly, if dictLength is Z_NULL, then it is not set.<br/>
		/// inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the<br/>
		/// stream state is inconsistent.<br/>
		/// </summary>
		public static int InflateSync(ZStream* strm)
		{
			int ret = InflateSyncNative(strm);
			return ret;
		}

		/// <summary>
		/// Skips invalid compressed data until a possible full flush point (see above<br/>
		/// for the description of deflate with Z_FULL_FLUSH) can be found, or until all<br/>
		/// available input is skipped.  No output is provided.<br/>
		/// inflateSync searches for a 00 00 FF FF pattern in the compressed data.<br/>
		/// All full flush points have this pattern, but not all occurrences of this<br/>
		/// pattern are full flush points.<br/>
		/// inflateSync returns Z_OK if a possible full flush point has been found,<br/>
		/// Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point<br/>
		/// has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.<br/>
		/// In the success case, the application may save the current value of total_in<br/>
		/// which indicates where valid compressed data was found.  In the error case,<br/>
		/// the application may repeatedly call inflateSync, providing more input each<br/>
		/// time, until success or end of the input data.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateCopyNative(ZStream* dest, ZStream* source)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, ZStream*, int>)funcTable[18])(dest, source);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[18])((nint)dest, (nint)source);
			#endif
		}

		/// <summary>
		/// Skips invalid compressed data until a possible full flush point (see above<br/>
		/// for the description of deflate with Z_FULL_FLUSH) can be found, or until all<br/>
		/// available input is skipped.  No output is provided.<br/>
		/// inflateSync searches for a 00 00 FF FF pattern in the compressed data.<br/>
		/// All full flush points have this pattern, but not all occurrences of this<br/>
		/// pattern are full flush points.<br/>
		/// inflateSync returns Z_OK if a possible full flush point has been found,<br/>
		/// Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point<br/>
		/// has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.<br/>
		/// In the success case, the application may save the current value of total_in<br/>
		/// which indicates where valid compressed data was found.  In the error case,<br/>
		/// the application may repeatedly call inflateSync, providing more input each<br/>
		/// time, until success or end of the input data.<br/>
		/// </summary>
		public static int InflateCopy(ZStream* dest, ZStream* source)
		{
			int ret = InflateCopyNative(dest, source);
			return ret;
		}

		/// <summary>
		/// Sets the destination stream as a complete copy of the source stream.<br/>
		/// This function can be useful when randomly accessing a large stream.  The<br/>
		/// first pass through the stream can periodically record the inflate state,<br/>
		/// allowing restarting inflate at those points when randomly accessing the<br/>
		/// stream.<br/>
		/// inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_STREAM_ERROR if the source stream state was inconsistent<br/>
		/// (such as zalloc being Z_NULL).  msg is left unchanged in both source and<br/>
		/// destination.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateResetNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[19])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[19])((nint)strm);
			#endif
		}

		/// <summary>
		/// Sets the destination stream as a complete copy of the source stream.<br/>
		/// This function can be useful when randomly accessing a large stream.  The<br/>
		/// first pass through the stream can periodically record the inflate state,<br/>
		/// allowing restarting inflate at those points when randomly accessing the<br/>
		/// stream.<br/>
		/// inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_STREAM_ERROR if the source stream state was inconsistent<br/>
		/// (such as zalloc being Z_NULL).  msg is left unchanged in both source and<br/>
		/// destination.<br/>
		/// </summary>
		public static int InflateReset(ZStream* strm)
		{
			int ret = InflateResetNative(strm);
			return ret;
		}

		/// <summary>
		/// This function is equivalent to inflateEnd followed by inflateInit,<br/>
		/// but does not free and reallocate the internal decompression state.  The<br/>
		/// stream will keep attributes that may have been set by inflateInit2.<br/>
		/// total_in, total_out, adler, and msg are initialized.<br/>
		/// inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateReset2Native(ZStream* strm, int windowBits)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int>)funcTable[20])(strm, windowBits);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[20])((nint)strm, windowBits);
			#endif
		}

		/// <summary>
		/// This function is equivalent to inflateEnd followed by inflateInit,<br/>
		/// but does not free and reallocate the internal decompression state.  The<br/>
		/// stream will keep attributes that may have been set by inflateInit2.<br/>
		/// total_in, total_out, adler, and msg are initialized.<br/>
		/// inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL).<br/>
		/// </summary>
		public static int InflateReset2(ZStream* strm, int windowBits)
		{
			int ret = InflateReset2Native(strm, windowBits);
			return ret;
		}

		/// <summary>
		/// This function is the same as inflateReset, but it also permits changing<br/>
		/// the wrap and window size requests.  The windowBits parameter is interpreted<br/>
		/// the same as it is for inflateInit2.  If the window size is changed, then the<br/>
		/// memory allocated for the window is freed, and the window will be reallocated<br/>
		/// by inflate() if needed.<br/>
		/// inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL), or if<br/>
		/// the windowBits parameter is invalid.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflatePrimeNative(ZStream* strm, int bits, int value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int, int>)funcTable[21])(strm, bits, value);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int>)funcTable[21])((nint)strm, bits, value);
			#endif
		}

		/// <summary>
		/// This function is the same as inflateReset, but it also permits changing<br/>
		/// the wrap and window size requests.  The windowBits parameter is interpreted<br/>
		/// the same as it is for inflateInit2.  If the window size is changed, then the<br/>
		/// memory allocated for the window is freed, and the window will be reallocated<br/>
		/// by inflate() if needed.<br/>
		/// inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent (such as zalloc or state being Z_NULL), or if<br/>
		/// the windowBits parameter is invalid.<br/>
		/// </summary>
		public static int InflatePrime(ZStream* strm, int bits, int value)
		{
			int ret = InflatePrimeNative(strm, bits, value);
			return ret;
		}

		/// <summary>
		/// This function inserts bits in the inflate input stream.  The intent is<br/>
		/// that this function is used to start inflating at a bit position in the<br/>
		/// middle of a byte.  The provided bits will be used before any bytes are used<br/>
		/// from next_in.  This function should only be used with raw inflate, and<br/>
		/// should be used before the first inflate() call after inflateInit2() or<br/>
		/// inflateReset().  bits must be less than or equal to 16, and that many of the<br/>
		/// least significant bits of value will be inserted in the input.<br/>
		/// If bits is negative, then the input stream bit buffer is emptied.  Then<br/>
		/// inflatePrime() can be called again to put bits in the buffer.  This is used<br/>
		/// to clear out bits leftover after feeding inflate a block description prior<br/>
		/// to feeding inflate codes.<br/>
		/// inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateMarkNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[22])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[22])((nint)strm);
			#endif
		}

		/// <summary>
		/// This function inserts bits in the inflate input stream.  The intent is<br/>
		/// that this function is used to start inflating at a bit position in the<br/>
		/// middle of a byte.  The provided bits will be used before any bytes are used<br/>
		/// from next_in.  This function should only be used with raw inflate, and<br/>
		/// should be used before the first inflate() call after inflateInit2() or<br/>
		/// inflateReset().  bits must be less than or equal to 16, and that many of the<br/>
		/// least significant bits of value will be inserted in the input.<br/>
		/// If bits is negative, then the input stream bit buffer is emptied.  Then<br/>
		/// inflatePrime() can be called again to put bits in the buffer.  This is used<br/>
		/// to clear out bits leftover after feeding inflate a block description prior<br/>
		/// to feeding inflate codes.<br/>
		/// inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source<br/>
		/// stream state was inconsistent.<br/>
		/// </summary>
		public static int InflateMark(ZStream* strm)
		{
			int ret = InflateMarkNative(strm);
			return ret;
		}

		/// <summary>
		/// This function returns two values, one in the lower 16 bits of the return<br/>
		/// value, and the other in the remaining upper bits, obtained by shifting the<br/>
		/// return value down 16 bits.  If the upper value is -1 and the lower value is<br/>
		/// zero, then inflate() is currently decoding information outside of a block.<br/>
		/// If the upper value is -1 and the lower value is non-zero, then inflate is in<br/>
		/// the middle of a stored block, with the lower value equaling the number of<br/>
		/// bytes from the input remaining to copy.  If the upper value is not -1, then<br/>
		/// it is the number of bits back from the current bit position in the input of<br/>
		/// the code (literal or length/distance pair) currently being processed.  In<br/>
		/// that case the lower value is the number of bytes already emitted for that<br/>
		/// code.<br/>
		/// A code is being processed if inflate is waiting for more input to complete<br/>
		/// decoding of the code, or if it has completed decoding but is waiting for<br/>
		/// more output space to write the literal or match data.<br/>
		/// inflateMark() is used to mark locations in the input data for random<br/>
		/// access, which may be at bit positions, and to note those cases where the<br/>
		/// output of a code may span boundaries of random access blocks.  The current<br/>
		/// location in the input stream can be determined from avail_in and data_type<br/>
		/// as noted in the description for the Z_BLOCK flush parameter for inflate.<br/>
		/// inflateMark returns the value noted above, or -65536 if the provided<br/>
		/// source stream state was inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateGetHeaderNative(ZStream* strm, GZHeader* head)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, GZHeader*, int>)funcTable[23])(strm, head);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[23])((nint)strm, (nint)head);
			#endif
		}

		/// <summary>
		/// This function returns two values, one in the lower 16 bits of the return<br/>
		/// value, and the other in the remaining upper bits, obtained by shifting the<br/>
		/// return value down 16 bits.  If the upper value is -1 and the lower value is<br/>
		/// zero, then inflate() is currently decoding information outside of a block.<br/>
		/// If the upper value is -1 and the lower value is non-zero, then inflate is in<br/>
		/// the middle of a stored block, with the lower value equaling the number of<br/>
		/// bytes from the input remaining to copy.  If the upper value is not -1, then<br/>
		/// it is the number of bits back from the current bit position in the input of<br/>
		/// the code (literal or length/distance pair) currently being processed.  In<br/>
		/// that case the lower value is the number of bytes already emitted for that<br/>
		/// code.<br/>
		/// A code is being processed if inflate is waiting for more input to complete<br/>
		/// decoding of the code, or if it has completed decoding but is waiting for<br/>
		/// more output space to write the literal or match data.<br/>
		/// inflateMark() is used to mark locations in the input data for random<br/>
		/// access, which may be at bit positions, and to note those cases where the<br/>
		/// output of a code may span boundaries of random access blocks.  The current<br/>
		/// location in the input stream can be determined from avail_in and data_type<br/>
		/// as noted in the description for the Z_BLOCK flush parameter for inflate.<br/>
		/// inflateMark returns the value noted above, or -65536 if the provided<br/>
		/// source stream state was inconsistent.<br/>
		/// </summary>
		public static int InflateGetHeader(ZStream* strm, GZHeader* head)
		{
			int ret = InflateGetHeaderNative(strm, head);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateBackNative(ZStream* strm, InFunc input, void* inDesc, OutFunc output, void* outDesc)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, delegate*<void*, byte**, uint>, void*, delegate*<void*, byte*, uint, int>, void*, int>)funcTable[24])(strm, (delegate*<void*, byte**, uint>)Utils.GetFunctionPointerForDelegate(input), inDesc, (delegate*<void*, byte*, uint, int>)Utils.GetFunctionPointerForDelegate(output), outDesc);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[24])((nint)strm, (nint)Utils.GetFunctionPointerForDelegate(input), (nint)inDesc, (nint)Utils.GetFunctionPointerForDelegate(output), (nint)outDesc);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBack(ZStream* strm, InFunc input, void* inDesc, OutFunc output, void* outDesc)
		{
			int ret = InflateBackNative(strm, input, inDesc, output, outDesc);
			return ret;
		}

		/// <summary>
		/// inflateBack() does a raw inflate with a single call using a call-back<br/>
		/// interface for input and output.  This is potentially more efficient than<br/>
		/// inflate() for file i/o applications, in that it avoids copying between the<br/>
		/// output and the sliding window by simply making the window itself the output<br/>
		/// buffer.  inflate() can be faster on modern CPUs when used with large<br/>
		/// buffers.  inflateBack() trusts the application to not change the output<br/>
		/// buffer passed by the output function, at least until inflateBack() returns.<br/>
		/// inflateBackInit() must be called first to allocate the internal state<br/>
		/// and to initialize the state with the user-provided window buffer.<br/>
		/// inflateBack() may then be used multiple times to inflate a complete, raw<br/>
		/// deflate stream with each call.  inflateBackEnd() is then called to free the<br/>
		/// allocated state.<br/>
		/// A raw deflate stream is one with no zlib or gzip header or trailer.<br/>
		/// This routine would normally be used in a utility that reads zip or gzip<br/>
		/// files and writes out uncompressed files.  The utility would decode the<br/>
		/// header and process the trailer on its own, hence this routine expects only<br/>
		/// the raw deflate stream to decompress.  This is different from the default<br/>
		/// behavior of inflate(), which expects a zlib header and trailer around the<br/>
		/// deflate stream.<br/>
		/// inflateBack() uses two subroutines supplied by the caller that are then<br/>
		/// called by inflateBack() for input and output.  inflateBack() calls those<br/>
		/// routines until it reads a complete deflate stream and writes out all of the<br/>
		/// uncompressed data, or until it encounters an error.  The function's<br/>
		/// parameters and return types are defined above in the in_func and out_func<br/>
		/// typedefs.  inflateBack() will call in(in_desc, <br/>
		/// &buf<br/>
		/// ) which should return the<br/>
		/// number of bytes of provided input, and a pointer to that input in buf.  If<br/>
		/// there is no input available, in() must return zero -- buf is ignored in that<br/>
		/// case -- and inflateBack() will return a buffer error.  inflateBack() will<br/>
		/// call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].<br/>
		/// out() should return zero on success, or non-zero on failure.  If out()<br/>
		/// returns non-zero, inflateBack() will return with an error.  Neither in() nor<br/>
		/// out() are permitted to change the contents of the window provided to<br/>
		/// inflateBackInit(), which is also the buffer that out() uses to write from.<br/>
		/// The length written by out() will be at most the window size.  Any non-zero<br/>
		/// amount of input may be provided by in().<br/>
		/// For convenience, inflateBack() can be provided input on the first call by<br/>
		/// setting strm->next_in and strm->avail_in.  If that input is exhausted, then<br/>
		/// in() will be called.  Therefore strm->next_in must be initialized before<br/>
		/// calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called<br/>
		/// immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in<br/>
		/// must also be initialized, and then if strm->avail_in is not zero, input will<br/>
		/// initially be taken from strm->next_in[0 ..  strm->avail_in - 1].<br/>
		/// The in_desc and out_desc parameters of inflateBack() is passed as the<br/>
		/// first parameter of in() and out() respectively when they are called.  These<br/>
		/// descriptors can be optionally used to pass any information that the caller-<br/>
		/// supplied in() and out() functions need to do their job.<br/>
		/// On return, inflateBack() will set strm->next_in and strm->avail_in to<br/>
		/// pass back any unused input that was provided by the last in() call.  The<br/>
		/// return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR<br/>
		/// if in() or out() returned an error, Z_DATA_ERROR if there was a format error<br/>
		/// in the deflate stream (in which case strm->msg is set to indicate the nature<br/>
		/// of the error), or Z_STREAM_ERROR if the stream was not properly initialized.<br/>
		/// In the case of Z_BUF_ERROR, an input or output error can be distinguished<br/>
		/// using strm->next_in which will be Z_NULL only if in() returned an error.  If<br/>
		/// strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning<br/>
		/// non-zero.  (in() will always be called before out(), so strm->next_in is<br/>
		/// assured to be defined if out() returns non-zero.)  Note that inflateBack()<br/>
		/// cannot return Z_OK.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateBackEndNative(ZStream* strm)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[25])(strm);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[25])((nint)strm);
			#endif
		}

		/// <summary>
		/// inflateBack() does a raw inflate with a single call using a call-back<br/>
		/// interface for input and output.  This is potentially more efficient than<br/>
		/// inflate() for file i/o applications, in that it avoids copying between the<br/>
		/// output and the sliding window by simply making the window itself the output<br/>
		/// buffer.  inflate() can be faster on modern CPUs when used with large<br/>
		/// buffers.  inflateBack() trusts the application to not change the output<br/>
		/// buffer passed by the output function, at least until inflateBack() returns.<br/>
		/// inflateBackInit() must be called first to allocate the internal state<br/>
		/// and to initialize the state with the user-provided window buffer.<br/>
		/// inflateBack() may then be used multiple times to inflate a complete, raw<br/>
		/// deflate stream with each call.  inflateBackEnd() is then called to free the<br/>
		/// allocated state.<br/>
		/// A raw deflate stream is one with no zlib or gzip header or trailer.<br/>
		/// This routine would normally be used in a utility that reads zip or gzip<br/>
		/// files and writes out uncompressed files.  The utility would decode the<br/>
		/// header and process the trailer on its own, hence this routine expects only<br/>
		/// the raw deflate stream to decompress.  This is different from the default<br/>
		/// behavior of inflate(), which expects a zlib header and trailer around the<br/>
		/// deflate stream.<br/>
		/// inflateBack() uses two subroutines supplied by the caller that are then<br/>
		/// called by inflateBack() for input and output.  inflateBack() calls those<br/>
		/// routines until it reads a complete deflate stream and writes out all of the<br/>
		/// uncompressed data, or until it encounters an error.  The function's<br/>
		/// parameters and return types are defined above in the in_func and out_func<br/>
		/// typedefs.  inflateBack() will call in(in_desc, <br/>
		/// &buf<br/>
		/// ) which should return the<br/>
		/// number of bytes of provided input, and a pointer to that input in buf.  If<br/>
		/// there is no input available, in() must return zero -- buf is ignored in that<br/>
		/// case -- and inflateBack() will return a buffer error.  inflateBack() will<br/>
		/// call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].<br/>
		/// out() should return zero on success, or non-zero on failure.  If out()<br/>
		/// returns non-zero, inflateBack() will return with an error.  Neither in() nor<br/>
		/// out() are permitted to change the contents of the window provided to<br/>
		/// inflateBackInit(), which is also the buffer that out() uses to write from.<br/>
		/// The length written by out() will be at most the window size.  Any non-zero<br/>
		/// amount of input may be provided by in().<br/>
		/// For convenience, inflateBack() can be provided input on the first call by<br/>
		/// setting strm->next_in and strm->avail_in.  If that input is exhausted, then<br/>
		/// in() will be called.  Therefore strm->next_in must be initialized before<br/>
		/// calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called<br/>
		/// immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in<br/>
		/// must also be initialized, and then if strm->avail_in is not zero, input will<br/>
		/// initially be taken from strm->next_in[0 ..  strm->avail_in - 1].<br/>
		/// The in_desc and out_desc parameters of inflateBack() is passed as the<br/>
		/// first parameter of in() and out() respectively when they are called.  These<br/>
		/// descriptors can be optionally used to pass any information that the caller-<br/>
		/// supplied in() and out() functions need to do their job.<br/>
		/// On return, inflateBack() will set strm->next_in and strm->avail_in to<br/>
		/// pass back any unused input that was provided by the last in() call.  The<br/>
		/// return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR<br/>
		/// if in() or out() returned an error, Z_DATA_ERROR if there was a format error<br/>
		/// in the deflate stream (in which case strm->msg is set to indicate the nature<br/>
		/// of the error), or Z_STREAM_ERROR if the stream was not properly initialized.<br/>
		/// In the case of Z_BUF_ERROR, an input or output error can be distinguished<br/>
		/// using strm->next_in which will be Z_NULL only if in() returned an error.  If<br/>
		/// strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning<br/>
		/// non-zero.  (in() will always be called before out(), so strm->next_in is<br/>
		/// assured to be defined if out() returns non-zero.)  Note that inflateBack()<br/>
		/// cannot return Z_OK.<br/>
		/// </summary>
		public static int InflateBackEnd(ZStream* strm)
		{
			int ret = InflateBackEndNative(strm);
			return ret;
		}

		/// <summary>
		/// All memory allocated by inflateBackInit() is freed.<br/>
		/// inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream<br/>
		/// state was inconsistent.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompileFlagsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[26])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[26])();
			#endif
		}

		/// <summary>
		/// All memory allocated by inflateBackInit() is freed.<br/>
		/// inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream<br/>
		/// state was inconsistent.<br/>
		/// </summary>
		public static uint CompileFlags()
		{
			uint ret = CompileFlagsNative();
			return ret;
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CompressNative(byte* dest, uint* destLen, byte* source, uint sourceLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint*, byte*, uint, int>)funcTable[27])(dest, destLen, source, sourceLen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, int>)funcTable[27])((nint)dest, (nint)destLen, (nint)source, sourceLen);
			#endif
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(byte* dest, uint* destLen, byte* source, uint sourceLen)
		{
			int ret = CompressNative(dest, destLen, source, sourceLen);
			return ret;
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(ref byte dest, uint* destLen, byte* source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				int ret = CompressNative((byte*)pdest, destLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(byte* dest, ref uint destLen, byte* source, uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				int ret = CompressNative(dest, (uint*)pdestLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(ref byte dest, ref uint destLen, byte* source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					int ret = CompressNative((byte*)pdest, (uint*)pdestLen, source, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(byte* dest, uint* destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* psource = &source)
			{
				int ret = CompressNative(dest, destLen, (byte*)psource, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(ref byte dest, uint* destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (byte* psource = &source)
				{
					int ret = CompressNative((byte*)pdest, destLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(byte* dest, ref uint destLen, ref byte source, uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (byte* psource = &source)
				{
					int ret = CompressNative(dest, (uint*)pdestLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// The following utility functions are implemented on top of the basic<br/>
		/// stream-oriented functions.  To simplify the interface, some default options<br/>
		/// are assumed (compression level and memory usage, standard memory allocation<br/>
		/// functions).  The source code of these utility functions can be modified if<br/>
		/// you need special options.<br/>
		/// </summary>
		public static int Compress(ref byte dest, ref uint destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (byte* psource = &source)
					{
						int ret = CompressNative((byte*)pdest, (uint*)pdestLen, (byte*)psource, sourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Compress2Native(byte* dest, uint* destLen, byte* source, uint sourceLen, int level)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint*, byte*, uint, int, int>)funcTable[28])(dest, destLen, source, sourceLen, level);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, int, int>)funcTable[28])((nint)dest, (nint)destLen, (nint)source, sourceLen, level);
			#endif
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(byte* dest, uint* destLen, byte* source, uint sourceLen, int level)
		{
			int ret = Compress2Native(dest, destLen, source, sourceLen, level);
			return ret;
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(ref byte dest, uint* destLen, byte* source, uint sourceLen, int level)
		{
			fixed (byte* pdest = &dest)
			{
				int ret = Compress2Native((byte*)pdest, destLen, source, sourceLen, level);
				return ret;
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(byte* dest, ref uint destLen, byte* source, uint sourceLen, int level)
		{
			fixed (uint* pdestLen = &destLen)
			{
				int ret = Compress2Native(dest, (uint*)pdestLen, source, sourceLen, level);
				return ret;
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(ref byte dest, ref uint destLen, byte* source, uint sourceLen, int level)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					int ret = Compress2Native((byte*)pdest, (uint*)pdestLen, source, sourceLen, level);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(byte* dest, uint* destLen, ref byte source, uint sourceLen, int level)
		{
			fixed (byte* psource = &source)
			{
				int ret = Compress2Native(dest, destLen, (byte*)psource, sourceLen, level);
				return ret;
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(ref byte dest, uint* destLen, ref byte source, uint sourceLen, int level)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (byte* psource = &source)
				{
					int ret = Compress2Native((byte*)pdest, destLen, (byte*)psource, sourceLen, level);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(byte* dest, ref uint destLen, ref byte source, uint sourceLen, int level)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (byte* psource = &source)
				{
					int ret = Compress2Native(dest, (uint*)pdestLen, (byte*)psource, sourceLen, level);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.  compress() is equivalent to compress2() with a level<br/>
		/// parameter of Z_DEFAULT_COMPRESSION.<br/>
		/// compress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer.<br/>
		/// </summary>
		public static int Compress2(ref byte dest, ref uint destLen, ref byte source, uint sourceLen, int level)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (byte* psource = &source)
					{
						int ret = Compress2Native((byte*)pdest, (uint*)pdestLen, (byte*)psource, sourceLen, level);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  The level<br/>
		/// parameter has the same meaning as in deflateInit.  sourceLen is the byte<br/>
		/// length of the source buffer.  Upon entry, destLen is the total size of the<br/>
		/// destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.<br/>
		/// compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_BUF_ERROR if there was not enough room in the output buffer,<br/>
		/// Z_STREAM_ERROR if the level parameter is invalid.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CompressBoundNative(uint sourceLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[29])(sourceLen);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[29])(sourceLen);
			#endif
		}

		/// <summary>
		/// Compresses the source buffer into the destination buffer.  The level<br/>
		/// parameter has the same meaning as in deflateInit.  sourceLen is the byte<br/>
		/// length of the source buffer.  Upon entry, destLen is the total size of the<br/>
		/// destination buffer, which must be at least the value returned by<br/>
		/// compressBound(sourceLen).  Upon exit, destLen is the actual size of the<br/>
		/// compressed data.<br/>
		/// compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough<br/>
		/// memory, Z_BUF_ERROR if there was not enough room in the output buffer,<br/>
		/// Z_STREAM_ERROR if the level parameter is invalid.<br/>
		/// </summary>
		public static uint CompressBound(uint sourceLen)
		{
			uint ret = CompressBoundNative(sourceLen);
			return ret;
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UncompressNative(byte* dest, uint* destLen, byte* source, uint sourceLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint*, byte*, uint, int>)funcTable[30])(dest, destLen, source, sourceLen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, uint, int>)funcTable[30])((nint)dest, (nint)destLen, (nint)source, sourceLen);
			#endif
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(byte* dest, uint* destLen, byte* source, uint sourceLen)
		{
			int ret = UncompressNative(dest, destLen, source, sourceLen);
			return ret;
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(ref byte dest, uint* destLen, byte* source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				int ret = UncompressNative((byte*)pdest, destLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(byte* dest, ref uint destLen, byte* source, uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				int ret = UncompressNative(dest, (uint*)pdestLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(ref byte dest, ref uint destLen, byte* source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					int ret = UncompressNative((byte*)pdest, (uint*)pdestLen, source, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(byte* dest, uint* destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* psource = &source)
			{
				int ret = UncompressNative(dest, destLen, (byte*)psource, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(ref byte dest, uint* destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (byte* psource = &source)
				{
					int ret = UncompressNative((byte*)pdest, destLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(byte* dest, ref uint destLen, ref byte source, uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (byte* psource = &source)
				{
					int ret = UncompressNative(dest, (uint*)pdestLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// compressBound() returns an upper bound on the compressed size after<br/>
		/// compress() or compress2() on sourceLen bytes.  It would be used before a<br/>
		/// compress() or compress2() call to allocate the destination buffer.<br/>
		/// </summary>
		public static int Uncompress(ref byte dest, ref uint destLen, ref byte source, uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (byte* psource = &source)
					{
						int ret = UncompressNative((byte*)pdest, (uint*)pdestLen, (byte*)psource, sourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Uncompress2Native(byte* dest, uint* destLen, byte* source, uint* sourceLen)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint*, byte*, uint*, int>)funcTable[31])(dest, destLen, source, sourceLen);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, int>)funcTable[31])((nint)dest, (nint)destLen, (nint)source, (nint)sourceLen);
			#endif
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, uint* destLen, byte* source, uint* sourceLen)
		{
			int ret = Uncompress2Native(dest, destLen, source, sourceLen);
			return ret;
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, uint* destLen, byte* source, uint* sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				int ret = Uncompress2Native((byte*)pdest, destLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, ref uint destLen, byte* source, uint* sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				int ret = Uncompress2Native(dest, (uint*)pdestLen, source, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, ref uint destLen, byte* source, uint* sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					int ret = Uncompress2Native((byte*)pdest, (uint*)pdestLen, source, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, uint* destLen, ref byte source, uint* sourceLen)
		{
			fixed (byte* psource = &source)
			{
				int ret = Uncompress2Native(dest, destLen, (byte*)psource, sourceLen);
				return ret;
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, uint* destLen, ref byte source, uint* sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (byte* psource = &source)
				{
					int ret = Uncompress2Native((byte*)pdest, destLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, ref uint destLen, ref byte source, uint* sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (byte* psource = &source)
				{
					int ret = Uncompress2Native(dest, (uint*)pdestLen, (byte*)psource, sourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, ref uint destLen, ref byte source, uint* sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (byte* psource = &source)
					{
						int ret = Uncompress2Native((byte*)pdest, (uint*)pdestLen, (byte*)psource, sourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, uint* destLen, byte* source, ref uint sourceLen)
		{
			fixed (uint* psourceLen = &sourceLen)
			{
				int ret = Uncompress2Native(dest, destLen, source, (uint*)psourceLen);
				return ret;
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, uint* destLen, byte* source, ref uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* psourceLen = &sourceLen)
				{
					int ret = Uncompress2Native((byte*)pdest, destLen, source, (uint*)psourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, ref uint destLen, byte* source, ref uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (uint* psourceLen = &sourceLen)
				{
					int ret = Uncompress2Native(dest, (uint*)pdestLen, source, (uint*)psourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, ref uint destLen, byte* source, ref uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (uint* psourceLen = &sourceLen)
					{
						int ret = Uncompress2Native((byte*)pdest, (uint*)pdestLen, source, (uint*)psourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, uint* destLen, ref byte source, ref uint sourceLen)
		{
			fixed (byte* psource = &source)
			{
				fixed (uint* psourceLen = &sourceLen)
				{
					int ret = Uncompress2Native(dest, destLen, (byte*)psource, (uint*)psourceLen);
					return ret;
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, uint* destLen, ref byte source, ref uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (byte* psource = &source)
				{
					fixed (uint* psourceLen = &sourceLen)
					{
						int ret = Uncompress2Native((byte*)pdest, destLen, (byte*)psource, (uint*)psourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(byte* dest, ref uint destLen, ref byte source, ref uint sourceLen)
		{
			fixed (uint* pdestLen = &destLen)
			{
				fixed (byte* psource = &source)
				{
					fixed (uint* psourceLen = &sourceLen)
					{
						int ret = Uncompress2Native(dest, (uint*)pdestLen, (byte*)psource, (uint*)psourceLen);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Decompresses the source buffer into the destination buffer.  sourceLen is<br/>
		/// the byte length of the source buffer.  Upon entry, destLen is the total size<br/>
		/// of the destination buffer, which must be large enough to hold the entire<br/>
		/// uncompressed data.  (The size of the uncompressed data must have been saved<br/>
		/// previously by the compressor and transmitted to the decompressor by some<br/>
		/// mechanism outside the scope of this compression library.) Upon exit, destLen<br/>
		/// is the actual size of the uncompressed data.<br/>
		/// uncompress returns Z_OK if success, Z_MEM_ERROR if there was not<br/>
		/// enough memory, Z_BUF_ERROR if there was not enough room in the output<br/>
		/// buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In<br/>
		/// the case where there is not enough room, uncompress() will fill the output<br/>
		/// buffer with the uncompressed data up to that point.<br/>
		/// </summary>
		public static int Uncompress2(ref byte dest, ref uint destLen, ref byte source, ref uint sourceLen)
		{
			fixed (byte* pdest = &dest)
			{
				fixed (uint* pdestLen = &destLen)
				{
					fixed (byte* psource = &source)
					{
						fixed (uint* psourceLen = &sourceLen)
						{
							int ret = Uncompress2Native((byte*)pdest, (uint*)pdestLen, (byte*)psource, (uint*)psourceLen);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);<br/>
		/// Open the gzip (.gz) file at path for reading and decompressing, or<br/>
		/// compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")<br/>
		/// but can also include a compression level ("wb9") or a strategy: 'f' for<br/>
		/// filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",<br/>
		/// 'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression<br/>
		/// as in "wb9F".  (See the description of deflateInit2 for more information<br/>
		/// about the strategy parameter.)  'T' will request transparent writing or<br/>
		/// appending with no compression and not using the gzip format.<br/>
		/// "a" can be used instead of "w" to request that the gzip stream that will<br/>
		/// be written be appended to the file.  "+" will result in an error, since<br/>
		/// reading and writing to the same gzip file is not supported.  The addition of<br/>
		/// "x" when writing will create the file exclusively, which fails if the file<br/>
		/// already exists.  On systems that support it, the addition of "e" when<br/>
		/// reading or writing will set the flag to close the file on an execve() call.<br/>
		/// These functions, as well as gzip, will read and decode a sequence of gzip<br/>
		/// streams in a file.  The append function of gzopen() can be used to create<br/>
		/// such a file.  (Also see gzflush() for another way to do this.)  When<br/>
		/// appending, gzopen does not test whether the file begins with a gzip stream,<br/>
		/// nor does it look for the end of the gzip streams to begin appending.  gzopen<br/>
		/// will simply append a gzip stream to the existing file.<br/>
		/// gzopen can be used to read a file which is not in gzip format; in this<br/>
		/// case gzread will directly read from the file without decompression.  When<br/>
		/// reading, this will be detected automatically by looking for the magic two-<br/>
		/// byte gzip header.<br/>
		/// gzopen returns NULL if the file could not be opened, if there was<br/>
		/// insufficient memory to allocate the gzFile state, or if an invalid mode was<br/>
		/// specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).<br/>
		/// errno can be checked to determine if the reason gzopen failed was that the<br/>
		/// file could not be opened.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GzFile DopenNative(int fd, byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, GzFile>)funcTable[32])(fd, mode);
			#else
			return (GzFile)((delegate* unmanaged[Cdecl]<int, nint, GzFile>)funcTable[32])(fd, (nint)mode);
			#endif
		}

		/// <summary>
		/// ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);<br/>
		/// Open the gzip (.gz) file at path for reading and decompressing, or<br/>
		/// compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")<br/>
		/// but can also include a compression level ("wb9") or a strategy: 'f' for<br/>
		/// filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",<br/>
		/// 'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression<br/>
		/// as in "wb9F".  (See the description of deflateInit2 for more information<br/>
		/// about the strategy parameter.)  'T' will request transparent writing or<br/>
		/// appending with no compression and not using the gzip format.<br/>
		/// "a" can be used instead of "w" to request that the gzip stream that will<br/>
		/// be written be appended to the file.  "+" will result in an error, since<br/>
		/// reading and writing to the same gzip file is not supported.  The addition of<br/>
		/// "x" when writing will create the file exclusively, which fails if the file<br/>
		/// already exists.  On systems that support it, the addition of "e" when<br/>
		/// reading or writing will set the flag to close the file on an execve() call.<br/>
		/// These functions, as well as gzip, will read and decode a sequence of gzip<br/>
		/// streams in a file.  The append function of gzopen() can be used to create<br/>
		/// such a file.  (Also see gzflush() for another way to do this.)  When<br/>
		/// appending, gzopen does not test whether the file begins with a gzip stream,<br/>
		/// nor does it look for the end of the gzip streams to begin appending.  gzopen<br/>
		/// will simply append a gzip stream to the existing file.<br/>
		/// gzopen can be used to read a file which is not in gzip format; in this<br/>
		/// case gzread will directly read from the file without decompression.  When<br/>
		/// reading, this will be detected automatically by looking for the magic two-<br/>
		/// byte gzip header.<br/>
		/// gzopen returns NULL if the file could not be opened, if there was<br/>
		/// insufficient memory to allocate the gzFile state, or if an invalid mode was<br/>
		/// specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).<br/>
		/// errno can be checked to determine if the reason gzopen failed was that the<br/>
		/// file could not be opened.<br/>
		/// </summary>
		public static GzFile Dopen(int fd, byte* mode)
		{
			GzFile ret = DopenNative(fd, mode);
			return ret;
		}

		/// <summary>
		/// ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);<br/>
		/// Open the gzip (.gz) file at path for reading and decompressing, or<br/>
		/// compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")<br/>
		/// but can also include a compression level ("wb9") or a strategy: 'f' for<br/>
		/// filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",<br/>
		/// 'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression<br/>
		/// as in "wb9F".  (See the description of deflateInit2 for more information<br/>
		/// about the strategy parameter.)  'T' will request transparent writing or<br/>
		/// appending with no compression and not using the gzip format.<br/>
		/// "a" can be used instead of "w" to request that the gzip stream that will<br/>
		/// be written be appended to the file.  "+" will result in an error, since<br/>
		/// reading and writing to the same gzip file is not supported.  The addition of<br/>
		/// "x" when writing will create the file exclusively, which fails if the file<br/>
		/// already exists.  On systems that support it, the addition of "e" when<br/>
		/// reading or writing will set the flag to close the file on an execve() call.<br/>
		/// These functions, as well as gzip, will read and decode a sequence of gzip<br/>
		/// streams in a file.  The append function of gzopen() can be used to create<br/>
		/// such a file.  (Also see gzflush() for another way to do this.)  When<br/>
		/// appending, gzopen does not test whether the file begins with a gzip stream,<br/>
		/// nor does it look for the end of the gzip streams to begin appending.  gzopen<br/>
		/// will simply append a gzip stream to the existing file.<br/>
		/// gzopen can be used to read a file which is not in gzip format; in this<br/>
		/// case gzread will directly read from the file without decompression.  When<br/>
		/// reading, this will be detected automatically by looking for the magic two-<br/>
		/// byte gzip header.<br/>
		/// gzopen returns NULL if the file could not be opened, if there was<br/>
		/// insufficient memory to allocate the gzFile state, or if an invalid mode was<br/>
		/// specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).<br/>
		/// errno can be checked to determine if the reason gzopen failed was that the<br/>
		/// file could not be opened.<br/>
		/// </summary>
		public static GzFile Dopen(int fd, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				GzFile ret = DopenNative(fd, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);<br/>
		/// Open the gzip (.gz) file at path for reading and decompressing, or<br/>
		/// compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")<br/>
		/// but can also include a compression level ("wb9") or a strategy: 'f' for<br/>
		/// filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",<br/>
		/// 'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression<br/>
		/// as in "wb9F".  (See the description of deflateInit2 for more information<br/>
		/// about the strategy parameter.)  'T' will request transparent writing or<br/>
		/// appending with no compression and not using the gzip format.<br/>
		/// "a" can be used instead of "w" to request that the gzip stream that will<br/>
		/// be written be appended to the file.  "+" will result in an error, since<br/>
		/// reading and writing to the same gzip file is not supported.  The addition of<br/>
		/// "x" when writing will create the file exclusively, which fails if the file<br/>
		/// already exists.  On systems that support it, the addition of "e" when<br/>
		/// reading or writing will set the flag to close the file on an execve() call.<br/>
		/// These functions, as well as gzip, will read and decode a sequence of gzip<br/>
		/// streams in a file.  The append function of gzopen() can be used to create<br/>
		/// such a file.  (Also see gzflush() for another way to do this.)  When<br/>
		/// appending, gzopen does not test whether the file begins with a gzip stream,<br/>
		/// nor does it look for the end of the gzip streams to begin appending.  gzopen<br/>
		/// will simply append a gzip stream to the existing file.<br/>
		/// gzopen can be used to read a file which is not in gzip format; in this<br/>
		/// case gzread will directly read from the file without decompression.  When<br/>
		/// reading, this will be detected automatically by looking for the magic two-<br/>
		/// byte gzip header.<br/>
		/// gzopen returns NULL if the file could not be opened, if there was<br/>
		/// insufficient memory to allocate the gzFile state, or if an invalid mode was<br/>
		/// specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).<br/>
		/// errno can be checked to determine if the reason gzopen failed was that the<br/>
		/// file could not be opened.<br/>
		/// </summary>
		public static GzFile Dopen(int fd, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				GzFile ret = DopenNative(fd, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);<br/>
		/// Open the gzip (.gz) file at path for reading and decompressing, or<br/>
		/// compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")<br/>
		/// but can also include a compression level ("wb9") or a strategy: 'f' for<br/>
		/// filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",<br/>
		/// 'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression<br/>
		/// as in "wb9F".  (See the description of deflateInit2 for more information<br/>
		/// about the strategy parameter.)  'T' will request transparent writing or<br/>
		/// appending with no compression and not using the gzip format.<br/>
		/// "a" can be used instead of "w" to request that the gzip stream that will<br/>
		/// be written be appended to the file.  "+" will result in an error, since<br/>
		/// reading and writing to the same gzip file is not supported.  The addition of<br/>
		/// "x" when writing will create the file exclusively, which fails if the file<br/>
		/// already exists.  On systems that support it, the addition of "e" when<br/>
		/// reading or writing will set the flag to close the file on an execve() call.<br/>
		/// These functions, as well as gzip, will read and decode a sequence of gzip<br/>
		/// streams in a file.  The append function of gzopen() can be used to create<br/>
		/// such a file.  (Also see gzflush() for another way to do this.)  When<br/>
		/// appending, gzopen does not test whether the file begins with a gzip stream,<br/>
		/// nor does it look for the end of the gzip streams to begin appending.  gzopen<br/>
		/// will simply append a gzip stream to the existing file.<br/>
		/// gzopen can be used to read a file which is not in gzip format; in this<br/>
		/// case gzread will directly read from the file without decompression.  When<br/>
		/// reading, this will be detected automatically by looking for the magic two-<br/>
		/// byte gzip header.<br/>
		/// gzopen returns NULL if the file could not be opened, if there was<br/>
		/// insufficient memory to allocate the gzFile state, or if an invalid mode was<br/>
		/// specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).<br/>
		/// errno can be checked to determine if the reason gzopen failed was that the<br/>
		/// file could not be opened.<br/>
		/// </summary>
		public static GzFile Dopen(int fd, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GzFile ret = DopenNative(fd, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Associate a gzFile with the file descriptor fd.  File descriptors are<br/>
		/// obtained from calls like open, dup, creat, pipe or fileno (if the file has<br/>
		/// been previously opened with fopen).  The mode parameter is as in gzopen.<br/>
		/// The next call of gzclose on the returned gzFile will also close the file<br/>
		/// descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor<br/>
		/// fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,<br/>
		/// mode);.  The duplicated descriptor should be saved to avoid a leak, since<br/>
		/// gzdopen does not close fd if it fails.  If you are using fileno() to get the<br/>
		/// file descriptor from a FILE *, then you will have to use dup() to avoid<br/>
		/// double-close()ing the file descriptor.  Both gzclose() and fclose() will<br/>
		/// close the associated file descriptor, so they need to have different file<br/>
		/// descriptors.<br/>
		/// gzdopen returns NULL if there was insufficient memory to allocate the<br/>
		/// gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not<br/>
		/// provided, or '+' was provided), or if fd is -1.  The file descriptor is not<br/>
		/// used until the next gz* read, write, seek, or close operation, so gzdopen<br/>
		/// will not detect if fd is invalid (unless fd is -1).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BufferNative(GzFile file, uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, uint, int>)funcTable[33])(file, size);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, uint, int>)funcTable[33])(file, size);
			#endif
		}

		/// <summary>
		/// Associate a gzFile with the file descriptor fd.  File descriptors are<br/>
		/// obtained from calls like open, dup, creat, pipe or fileno (if the file has<br/>
		/// been previously opened with fopen).  The mode parameter is as in gzopen.<br/>
		/// The next call of gzclose on the returned gzFile will also close the file<br/>
		/// descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor<br/>
		/// fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,<br/>
		/// mode);.  The duplicated descriptor should be saved to avoid a leak, since<br/>
		/// gzdopen does not close fd if it fails.  If you are using fileno() to get the<br/>
		/// file descriptor from a FILE *, then you will have to use dup() to avoid<br/>
		/// double-close()ing the file descriptor.  Both gzclose() and fclose() will<br/>
		/// close the associated file descriptor, so they need to have different file<br/>
		/// descriptors.<br/>
		/// gzdopen returns NULL if there was insufficient memory to allocate the<br/>
		/// gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not<br/>
		/// provided, or '+' was provided), or if fd is -1.  The file descriptor is not<br/>
		/// used until the next gz* read, write, seek, or close operation, so gzdopen<br/>
		/// will not detect if fd is invalid (unless fd is -1).<br/>
		/// </summary>
		public static int Buffer(GzFile file, uint size)
		{
			int ret = BufferNative(file, size);
			return ret;
		}

		/// <summary>
		/// Set the internal buffer size used by this library's functions for file to<br/>
		/// size.  The default buffer size is 8192 bytes.  This function must be called<br/>
		/// after gzopen() or gzdopen(), and before any other calls that read or write<br/>
		/// the file.  The buffer memory allocation is always deferred to the first read<br/>
		/// or write.  Three times that size in buffer space is allocated.  A larger<br/>
		/// buffer size of, for example, 64K or 128K bytes will noticeably increase the<br/>
		/// speed of decompression (reading).<br/>
		/// The new buffer size also affects the maximum length for gzprintf().<br/>
		/// gzbuffer() returns 0 on success, or -1 on failure, such as being called<br/>
		/// too late.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SetparamsNative(GzFile file, int level, int strategy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int, int, int>)funcTable[34])(file, level, strategy);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int, int, int>)funcTable[34])(file, level, strategy);
			#endif
		}

		/// <summary>
		/// Set the internal buffer size used by this library's functions for file to<br/>
		/// size.  The default buffer size is 8192 bytes.  This function must be called<br/>
		/// after gzopen() or gzdopen(), and before any other calls that read or write<br/>
		/// the file.  The buffer memory allocation is always deferred to the first read<br/>
		/// or write.  Three times that size in buffer space is allocated.  A larger<br/>
		/// buffer size of, for example, 64K or 128K bytes will noticeably increase the<br/>
		/// speed of decompression (reading).<br/>
		/// The new buffer size also affects the maximum length for gzprintf().<br/>
		/// gzbuffer() returns 0 on success, or -1 on failure, such as being called<br/>
		/// too late.<br/>
		/// </summary>
		public static int Setparams(GzFile file, int level, int strategy)
		{
			int ret = SetparamsNative(file, level, strategy);
			return ret;
		}

		/// <summary>
		/// Dynamically update the compression level and strategy for file.  See the<br/>
		/// description of deflateInit2 for the meaning of these parameters. Previously<br/>
		/// provided data is flushed before applying the parameter changes.<br/>
		/// gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not<br/>
		/// opened for writing, Z_ERRNO if there is an error writing the flushed data,<br/>
		/// or Z_MEM_ERROR if there is a memory allocation error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ReadNative(GzFile file, void* buf, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, void*, uint, int>)funcTable[35])(file, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, nint, uint, int>)funcTable[35])(file, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Dynamically update the compression level and strategy for file.  See the<br/>
		/// description of deflateInit2 for the meaning of these parameters. Previously<br/>
		/// provided data is flushed before applying the parameter changes.<br/>
		/// gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not<br/>
		/// opened for writing, Z_ERRNO if there is an error writing the flushed data,<br/>
		/// or Z_MEM_ERROR if there is a memory allocation error.<br/>
		/// </summary>
		public static int Read(GzFile file, void* buf, uint len)
		{
			int ret = ReadNative(file, buf, len);
			return ret;
		}

		/// <summary>
		/// Read and decompress up to len uncompressed bytes from file into buf.  If<br/>
		/// the input file is not in gzip format, gzread copies the given number of<br/>
		/// bytes into the buffer directly from the file.<br/>
		/// After reaching the end of a gzip stream in the input, gzread will continue<br/>
		/// to read, looking for another gzip stream.  Any number of gzip streams may be<br/>
		/// concatenated in the input file, and will all be decompressed by gzread().<br/>
		/// If something other than a gzip stream is encountered after a gzip stream,<br/>
		/// that remaining trailing garbage is ignored (and no error is returned).<br/>
		/// gzread can be used to read a gzip file that is being concurrently written.<br/>
		/// Upon reaching the end of the input, gzread will return with the available<br/>
		/// data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then<br/>
		/// gzclearerr can be used to clear the end of file indicator in order to permit<br/>
		/// gzread to be tried again.  Z_OK indicates that a gzip stream was completed<br/>
		/// on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the<br/>
		/// middle of a gzip stream.  Note that gzread does not return -1 in the event<br/>
		/// of an incomplete gzip stream.  This error is deferred until gzclose(), which<br/>
		/// will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip<br/>
		/// stream.  Alternatively, gzerror can be used before gzclose to detect this<br/>
		/// case.<br/>
		/// gzread returns the number of uncompressed bytes actually read, less than<br/>
		/// len for end of file, or -1 for error.  If len is too large to fit in an int,<br/>
		/// then nothing is read, -1 is returned, and the error state is set to<br/>
		/// Z_STREAM_ERROR.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nint FreadNative(void* buf, nint size, nint nitems, GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nint, nint, GzFile, nint>)funcTable[36])(buf, size, nitems, file);
			#else
			return (nint)((delegate* unmanaged[Cdecl]<nint, nint, nint, GzFile, nint>)funcTable[36])((nint)buf, size, nitems, file);
			#endif
		}

		/// <summary>
		/// Read and decompress up to len uncompressed bytes from file into buf.  If<br/>
		/// the input file is not in gzip format, gzread copies the given number of<br/>
		/// bytes into the buffer directly from the file.<br/>
		/// After reaching the end of a gzip stream in the input, gzread will continue<br/>
		/// to read, looking for another gzip stream.  Any number of gzip streams may be<br/>
		/// concatenated in the input file, and will all be decompressed by gzread().<br/>
		/// If something other than a gzip stream is encountered after a gzip stream,<br/>
		/// that remaining trailing garbage is ignored (and no error is returned).<br/>
		/// gzread can be used to read a gzip file that is being concurrently written.<br/>
		/// Upon reaching the end of the input, gzread will return with the available<br/>
		/// data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then<br/>
		/// gzclearerr can be used to clear the end of file indicator in order to permit<br/>
		/// gzread to be tried again.  Z_OK indicates that a gzip stream was completed<br/>
		/// on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the<br/>
		/// middle of a gzip stream.  Note that gzread does not return -1 in the event<br/>
		/// of an incomplete gzip stream.  This error is deferred until gzclose(), which<br/>
		/// will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip<br/>
		/// stream.  Alternatively, gzerror can be used before gzclose to detect this<br/>
		/// case.<br/>
		/// gzread returns the number of uncompressed bytes actually read, less than<br/>
		/// len for end of file, or -1 for error.  If len is too large to fit in an int,<br/>
		/// then nothing is read, -1 is returned, and the error state is set to<br/>
		/// Z_STREAM_ERROR.<br/>
		/// </summary>
		public static nint Fread(void* buf, nint size, nint nitems, GzFile file)
		{
			nint ret = FreadNative(buf, size, nitems, file);
			return ret;
		}

		/// <summary>
		/// Read and decompress up to nitems items of size size from file into buf,<br/>
		/// otherwise operating as gzread() does.  This duplicates the interface of<br/>
		/// stdio's fread(), with size_t request and return types.  If the library<br/>
		/// defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t<br/>
		/// is an unsigned integer type that can contain a pointer.<br/>
		/// gzfread() returns the number of full items read of size size, or zero if<br/>
		/// the end of the file was reached and a full item could not be read, or if<br/>
		/// there was an error.  gzerror() must be consulted if zero is returned in<br/>
		/// order to determine if there was an error.  If the multiplication of size and<br/>
		/// nitems overflows, i.e. the product does not fit in a z_size_t, then nothing<br/>
		/// is read, zero is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// In the event that the end of file is reached and only a partial item is<br/>
		/// available at the end, i.e. the remaining uncompressed data length is not a<br/>
		/// multiple of size, then the final partial item is nevertheless read into buf<br/>
		/// and the end-of-file flag is set.  The length of the partial item read is not<br/>
		/// provided, but could be inferred from the result of gztell().  This behavior<br/>
		/// is the same as the behavior of fread() implementations in common libraries,<br/>
		/// but it prevents the direct use of gzfread() to read a concurrently written<br/>
		/// file, resetting and retrying on end-of-file, when size is not 1.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int WriteNative(GzFile file, void* buf, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, void*, uint, int>)funcTable[37])(file, buf, len);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, nint, uint, int>)funcTable[37])(file, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Read and decompress up to nitems items of size size from file into buf,<br/>
		/// otherwise operating as gzread() does.  This duplicates the interface of<br/>
		/// stdio's fread(), with size_t request and return types.  If the library<br/>
		/// defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t<br/>
		/// is an unsigned integer type that can contain a pointer.<br/>
		/// gzfread() returns the number of full items read of size size, or zero if<br/>
		/// the end of the file was reached and a full item could not be read, or if<br/>
		/// there was an error.  gzerror() must be consulted if zero is returned in<br/>
		/// order to determine if there was an error.  If the multiplication of size and<br/>
		/// nitems overflows, i.e. the product does not fit in a z_size_t, then nothing<br/>
		/// is read, zero is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// In the event that the end of file is reached and only a partial item is<br/>
		/// available at the end, i.e. the remaining uncompressed data length is not a<br/>
		/// multiple of size, then the final partial item is nevertheless read into buf<br/>
		/// and the end-of-file flag is set.  The length of the partial item read is not<br/>
		/// provided, but could be inferred from the result of gztell().  This behavior<br/>
		/// is the same as the behavior of fread() implementations in common libraries,<br/>
		/// but it prevents the direct use of gzfread() to read a concurrently written<br/>
		/// file, resetting and retrying on end-of-file, when size is not 1.<br/>
		/// </summary>
		public static int Write(GzFile file, void* buf, uint len)
		{
			int ret = WriteNative(file, buf, len);
			return ret;
		}

		/// <summary>
		/// Compress and write the len uncompressed bytes at buf to file. gzwrite<br/>
		/// returns the number of uncompressed bytes written or 0 in case of error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nint FwriteNative(void* buf, nint size, nint nitems, GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, nint, nint, GzFile, nint>)funcTable[38])(buf, size, nitems, file);
			#else
			return (nint)((delegate* unmanaged[Cdecl]<nint, nint, nint, GzFile, nint>)funcTable[38])((nint)buf, size, nitems, file);
			#endif
		}

		/// <summary>
		/// Compress and write the len uncompressed bytes at buf to file. gzwrite<br/>
		/// returns the number of uncompressed bytes written or 0 in case of error.<br/>
		/// </summary>
		public static nint Fwrite(void* buf, nint size, nint nitems, GzFile file)
		{
			nint ret = FwriteNative(buf, size, nitems, file);
			return ret;
		}

		/// <summary>
		/// Compress and write nitems items of size size from buf to file, duplicating<br/>
		/// the interface of stdio's fwrite(), with size_t request and return types.  If<br/>
		/// the library defines size_t, then z_size_t is identical to size_t.  If not,<br/>
		/// then z_size_t is an unsigned integer type that can contain a pointer.<br/>
		/// gzfwrite() returns the number of full items written of size size, or zero<br/>
		/// if there was an error.  If the multiplication of size and nitems overflows,<br/>
		/// i.e. the product does not fit in a z_size_t, then nothing is written, zero<br/>
		/// is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PrintfNative(GzFile file, byte* format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, byte*, int>)funcTable[39])(file, format);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, nint, int>)funcTable[39])(file, (nint)format);
			#endif
		}

		/// <summary>
		/// Compress and write nitems items of size size from buf to file, duplicating<br/>
		/// the interface of stdio's fwrite(), with size_t request and return types.  If<br/>
		/// the library defines size_t, then z_size_t is identical to size_t.  If not,<br/>
		/// then z_size_t is an unsigned integer type that can contain a pointer.<br/>
		/// gzfwrite() returns the number of full items written of size size, or zero<br/>
		/// if there was an error.  If the multiplication of size and nitems overflows,<br/>
		/// i.e. the product does not fit in a z_size_t, then nothing is written, zero<br/>
		/// is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// </summary>
		public static int Printf(GzFile file, byte* format)
		{
			int ret = PrintfNative(file, format);
			return ret;
		}

		/// <summary>
		/// Compress and write nitems items of size size from buf to file, duplicating<br/>
		/// the interface of stdio's fwrite(), with size_t request and return types.  If<br/>
		/// the library defines size_t, then z_size_t is identical to size_t.  If not,<br/>
		/// then z_size_t is an unsigned integer type that can contain a pointer.<br/>
		/// gzfwrite() returns the number of full items written of size size, or zero<br/>
		/// if there was an error.  If the multiplication of size and nitems overflows,<br/>
		/// i.e. the product does not fit in a z_size_t, then nothing is written, zero<br/>
		/// is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// </summary>
		public static int Printf(GzFile file, ref byte format)
		{
			fixed (byte* pformat = &format)
			{
				int ret = PrintfNative(file, (byte*)pformat);
				return ret;
			}
		}

		/// <summary>
		/// Compress and write nitems items of size size from buf to file, duplicating<br/>
		/// the interface of stdio's fwrite(), with size_t request and return types.  If<br/>
		/// the library defines size_t, then z_size_t is identical to size_t.  If not,<br/>
		/// then z_size_t is an unsigned integer type that can contain a pointer.<br/>
		/// gzfwrite() returns the number of full items written of size size, or zero<br/>
		/// if there was an error.  If the multiplication of size and nitems overflows,<br/>
		/// i.e. the product does not fit in a z_size_t, then nothing is written, zero<br/>
		/// is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// </summary>
		public static int Printf(GzFile file, ReadOnlySpan<byte> format)
		{
			fixed (byte* pformat = format)
			{
				int ret = PrintfNative(file, (byte*)pformat);
				return ret;
			}
		}

		/// <summary>
		/// Compress and write nitems items of size size from buf to file, duplicating<br/>
		/// the interface of stdio's fwrite(), with size_t request and return types.  If<br/>
		/// the library defines size_t, then z_size_t is identical to size_t.  If not,<br/>
		/// then z_size_t is an unsigned integer type that can contain a pointer.<br/>
		/// gzfwrite() returns the number of full items written of size size, or zero<br/>
		/// if there was an error.  If the multiplication of size and nitems overflows,<br/>
		/// i.e. the product does not fit in a z_size_t, then nothing is written, zero<br/>
		/// is returned, and the error state is set to Z_STREAM_ERROR.<br/>
		/// </summary>
		public static int Printf(GzFile file, string format)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PrintfNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Convert, format, compress, and write the arguments (...) to file under<br/>
		/// control of the string format, as in fprintf.  gzprintf returns the number of<br/>
		/// uncompressed bytes actually written, or a negative zlib error code in case<br/>
		/// of error.  The number of uncompressed bytes written is limited to 8191, or<br/>
		/// one less than the buffer size given to gzbuffer().  The caller should assure<br/>
		/// that this limit is not exceeded.  If it is exceeded, then gzprintf() will<br/>
		/// return an error (0) with nothing written.  In this case, there may also be a<br/>
		/// buffer overflow with unpredictable consequences, which is possible only if<br/>
		/// zlib was compiled with the insecure functions sprintf() or vsprintf(),<br/>
		/// because the secure snprintf() or vsnprintf() functions were not available.<br/>
		/// This can be determined using zlibCompileFlags().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PutsNative(GzFile file, byte* s)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, byte*, int>)funcTable[40])(file, s);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, nint, int>)funcTable[40])(file, (nint)s);
			#endif
		}

		/// <summary>
		/// Convert, format, compress, and write the arguments (...) to file under<br/>
		/// control of the string format, as in fprintf.  gzprintf returns the number of<br/>
		/// uncompressed bytes actually written, or a negative zlib error code in case<br/>
		/// of error.  The number of uncompressed bytes written is limited to 8191, or<br/>
		/// one less than the buffer size given to gzbuffer().  The caller should assure<br/>
		/// that this limit is not exceeded.  If it is exceeded, then gzprintf() will<br/>
		/// return an error (0) with nothing written.  In this case, there may also be a<br/>
		/// buffer overflow with unpredictable consequences, which is possible only if<br/>
		/// zlib was compiled with the insecure functions sprintf() or vsprintf(),<br/>
		/// because the secure snprintf() or vsnprintf() functions were not available.<br/>
		/// This can be determined using zlibCompileFlags().<br/>
		/// </summary>
		public static int Puts(GzFile file, byte* s)
		{
			int ret = PutsNative(file, s);
			return ret;
		}

		/// <summary>
		/// Convert, format, compress, and write the arguments (...) to file under<br/>
		/// control of the string format, as in fprintf.  gzprintf returns the number of<br/>
		/// uncompressed bytes actually written, or a negative zlib error code in case<br/>
		/// of error.  The number of uncompressed bytes written is limited to 8191, or<br/>
		/// one less than the buffer size given to gzbuffer().  The caller should assure<br/>
		/// that this limit is not exceeded.  If it is exceeded, then gzprintf() will<br/>
		/// return an error (0) with nothing written.  In this case, there may also be a<br/>
		/// buffer overflow with unpredictable consequences, which is possible only if<br/>
		/// zlib was compiled with the insecure functions sprintf() or vsprintf(),<br/>
		/// because the secure snprintf() or vsnprintf() functions were not available.<br/>
		/// This can be determined using zlibCompileFlags().<br/>
		/// </summary>
		public static int Puts(GzFile file, ref byte s)
		{
			fixed (byte* ps = &s)
			{
				int ret = PutsNative(file, (byte*)ps);
				return ret;
			}
		}

		/// <summary>
		/// Convert, format, compress, and write the arguments (...) to file under<br/>
		/// control of the string format, as in fprintf.  gzprintf returns the number of<br/>
		/// uncompressed bytes actually written, or a negative zlib error code in case<br/>
		/// of error.  The number of uncompressed bytes written is limited to 8191, or<br/>
		/// one less than the buffer size given to gzbuffer().  The caller should assure<br/>
		/// that this limit is not exceeded.  If it is exceeded, then gzprintf() will<br/>
		/// return an error (0) with nothing written.  In this case, there may also be a<br/>
		/// buffer overflow with unpredictable consequences, which is possible only if<br/>
		/// zlib was compiled with the insecure functions sprintf() or vsprintf(),<br/>
		/// because the secure snprintf() or vsnprintf() functions were not available.<br/>
		/// This can be determined using zlibCompileFlags().<br/>
		/// </summary>
		public static int Puts(GzFile file, ReadOnlySpan<byte> s)
		{
			fixed (byte* ps = s)
			{
				int ret = PutsNative(file, (byte*)ps);
				return ret;
			}
		}

		/// <summary>
		/// Convert, format, compress, and write the arguments (...) to file under<br/>
		/// control of the string format, as in fprintf.  gzprintf returns the number of<br/>
		/// uncompressed bytes actually written, or a negative zlib error code in case<br/>
		/// of error.  The number of uncompressed bytes written is limited to 8191, or<br/>
		/// one less than the buffer size given to gzbuffer().  The caller should assure<br/>
		/// that this limit is not exceeded.  If it is exceeded, then gzprintf() will<br/>
		/// return an error (0) with nothing written.  In this case, there may also be a<br/>
		/// buffer overflow with unpredictable consequences, which is possible only if<br/>
		/// zlib was compiled with the insecure functions sprintf() or vsprintf(),<br/>
		/// because the secure snprintf() or vsnprintf() functions were not available.<br/>
		/// This can be determined using zlibCompileFlags().<br/>
		/// </summary>
		public static int Puts(GzFile file, string s)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (s != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(s);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(s, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = PutsNative(file, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetsNative(GzFile file, byte* buf, int len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, byte*, int, byte*>)funcTable[41])(file, buf, len);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GzFile, nint, int, nint>)funcTable[41])(file, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static byte* Gets(GzFile file, byte* buf, int len)
		{
			byte* ret = GetsNative(file, buf, len);
			return ret;
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static string GetsS(GzFile file, byte* buf, int len)
		{
			string ret = Utils.DecodeStringUTF8(GetsNative(file, buf, len));
			return ret;
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static byte* Gets(GzFile file, ref byte buf, int len)
		{
			fixed (byte* pbuf = &buf)
			{
				byte* ret = GetsNative(file, (byte*)pbuf, len);
				return ret;
			}
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static string GetsS(GzFile file, ref byte buf, int len)
		{
			fixed (byte* pbuf = &buf)
			{
				string ret = Utils.DecodeStringUTF8(GetsNative(file, (byte*)pbuf, len));
				return ret;
			}
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static byte* Gets(GzFile file, ref string buf, int len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = GetsNative(file, pStr0, len);
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Compress and write the given null-terminated string s to file, excluding<br/>
		/// the terminating null character.<br/>
		/// gzputs returns the number of characters written, or -1 in case of error.<br/>
		/// </summary>
		public static string GetsS(GzFile file, ref string buf, int len)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(GetsNative(file, pStr0, len));
			buf = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Read and decompress bytes from file into buf, until len-1 characters are<br/>
		/// read, or until a newline character is read and transferred to buf, or an<br/>
		/// end-of-file condition is encountered.  If any characters are read or if len<br/>
		/// is one, the string is terminated with a null character.  If no characters<br/>
		/// are read due to an end-of-file or len is less than one, then the buffer is<br/>
		/// left untouched.<br/>
		/// gzgets returns buf which is a null-terminated string, or it returns NULL<br/>
		/// for end-of-file or in case of error.  If there was an error, the contents at<br/>
		/// buf are indeterminate.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int PutcNative(GzFile file, int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int, int>)funcTable[42])(file, c);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int, int>)funcTable[42])(file, c);
			#endif
		}

		/// <summary>
		/// Read and decompress bytes from file into buf, until len-1 characters are<br/>
		/// read, or until a newline character is read and transferred to buf, or an<br/>
		/// end-of-file condition is encountered.  If any characters are read or if len<br/>
		/// is one, the string is terminated with a null character.  If no characters<br/>
		/// are read due to an end-of-file or len is less than one, then the buffer is<br/>
		/// left untouched.<br/>
		/// gzgets returns buf which is a null-terminated string, or it returns NULL<br/>
		/// for end-of-file or in case of error.  If there was an error, the contents at<br/>
		/// buf are indeterminate.<br/>
		/// </summary>
		public static int Putc(GzFile file, int c)
		{
			int ret = PutcNative(file, c);
			return ret;
		}

		/// <summary>
		/// Compress and write c, converted to an unsigned char, into file.  gzputc<br/>
		/// returns the value that was written, or -1 in case of error.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetcNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[43])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[43])(file);
			#endif
		}

		/// <summary>
		/// Compress and write c, converted to an unsigned char, into file.  gzputc<br/>
		/// returns the value that was written, or -1 in case of error.<br/>
		/// </summary>
		public static int Getc(GzFile file)
		{
			int ret = GetcNative(file);
			return ret;
		}

		/// <summary>
		/// Read and decompress one byte from file.  gzgetc returns this byte or -1<br/>
		/// in case of end of file or error.  This is implemented as a macro for speed.<br/>
		/// As such, it does not do all of the checking the other functions do.  I.e.<br/>
		/// it does not check to see if file is NULL, nor whether the structure file<br/>
		/// points to has been clobbered or not.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UngetcNative(int c, GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, GzFile, int>)funcTable[44])(c, file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, GzFile, int>)funcTable[44])(c, file);
			#endif
		}

		/// <summary>
		/// Read and decompress one byte from file.  gzgetc returns this byte or -1<br/>
		/// in case of end of file or error.  This is implemented as a macro for speed.<br/>
		/// As such, it does not do all of the checking the other functions do.  I.e.<br/>
		/// it does not check to see if file is NULL, nor whether the structure file<br/>
		/// points to has been clobbered or not.<br/>
		/// </summary>
		public static int Ungetc(int c, GzFile file)
		{
			int ret = UngetcNative(c, file);
			return ret;
		}

		/// <summary>
		/// Push c back onto the stream for file to be read as the first character on<br/>
		/// the next read.  At least one character of push-back is always allowed.<br/>
		/// gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will<br/>
		/// fail if c is -1, and may fail if a character has been pushed but not read<br/>
		/// yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the<br/>
		/// output buffer size of pushed characters is allowed.  (See gzbuffer above.)<br/>
		/// The pushed character will be discarded if the stream is repositioned with<br/>
		/// gzseek() or gzrewind().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FlushNative(GzFile file, int flush)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int, int>)funcTable[45])(file, flush);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int, int>)funcTable[45])(file, flush);
			#endif
		}

		/// <summary>
		/// Push c back onto the stream for file to be read as the first character on<br/>
		/// the next read.  At least one character of push-back is always allowed.<br/>
		/// gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will<br/>
		/// fail if c is -1, and may fail if a character has been pushed but not read<br/>
		/// yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the<br/>
		/// output buffer size of pushed characters is allowed.  (See gzbuffer above.)<br/>
		/// The pushed character will be discarded if the stream is repositioned with<br/>
		/// gzseek() or gzrewind().<br/>
		/// </summary>
		public static int Flush(GzFile file, int flush)
		{
			int ret = FlushNative(file, flush);
			return ret;
		}

		/// <summary>
		/// ZEXTERN z_off_t ZEXPORT gzseek(gzFile file,<br/>
		/// z_off_t offset, int whence);<br/>
		/// Set the starting position to offset relative to whence for the next gzread<br/>
		/// or gzwrite on file.  The offset represents a number of bytes in the<br/>
		/// uncompressed data stream.  The whence parameter is defined as in lseek(2);<br/>
		/// the value SEEK_END is not supported.<br/>
		/// If the file is opened for reading, this function is emulated but can be<br/>
		/// extremely slow.  If the file is opened for writing, only forward seeks are<br/>
		/// supported; gzseek then compresses a sequence of zeroes up to the new<br/>
		/// starting position.<br/>
		/// gzseek returns the resulting offset location as measured in bytes from<br/>
		/// the beginning of the uncompressed stream, or -1 in case of error, in<br/>
		/// particular if the file is opened for writing and the new starting position<br/>
		/// would be before the current position.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RewindNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[46])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[46])(file);
			#endif
		}

		/// <summary>
		/// ZEXTERN z_off_t ZEXPORT gzseek(gzFile file,<br/>
		/// z_off_t offset, int whence);<br/>
		/// Set the starting position to offset relative to whence for the next gzread<br/>
		/// or gzwrite on file.  The offset represents a number of bytes in the<br/>
		/// uncompressed data stream.  The whence parameter is defined as in lseek(2);<br/>
		/// the value SEEK_END is not supported.<br/>
		/// If the file is opened for reading, this function is emulated but can be<br/>
		/// extremely slow.  If the file is opened for writing, only forward seeks are<br/>
		/// supported; gzseek then compresses a sequence of zeroes up to the new<br/>
		/// starting position.<br/>
		/// gzseek returns the resulting offset location as measured in bytes from<br/>
		/// the beginning of the uncompressed stream, or -1 in case of error, in<br/>
		/// particular if the file is opened for writing and the new starting position<br/>
		/// would be before the current position.<br/>
		/// </summary>
		public static int Rewind(GzFile file)
		{
			int ret = RewindNative(file);
			return ret;
		}

		/// <summary>
		/// ZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);<br/>
		/// Return the current compressed (actual) read or write offset of file.  This<br/>
		/// offset includes the count of bytes that precede the gzip stream, for example<br/>
		/// when appending or when using gzdopen() for reading.  When reading, the<br/>
		/// offset does not include as yet unused buffered input.  This information can<br/>
		/// be used for a progress indicator.  On error, gzoffset() returns -1.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int EofNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[47])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[47])(file);
			#endif
		}

		/// <summary>
		/// ZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);<br/>
		/// Return the current compressed (actual) read or write offset of file.  This<br/>
		/// offset includes the count of bytes that precede the gzip stream, for example<br/>
		/// when appending or when using gzdopen() for reading.  When reading, the<br/>
		/// offset does not include as yet unused buffered input.  This information can<br/>
		/// be used for a progress indicator.  On error, gzoffset() returns -1.<br/>
		/// </summary>
		public static int Eof(GzFile file)
		{
			int ret = EofNative(file);
			return ret;
		}

		/// <summary>
		/// Return true (1) if the end-of-file indicator for file has been set while<br/>
		/// reading, false (0) otherwise.  Note that the end-of-file indicator is set<br/>
		/// only if the read tried to go past the end of the input, but came up short.<br/>
		/// Therefore, just like feof(), gzeof() may return false even if there is no<br/>
		/// more data to read, in the event that the last read request was for the exact<br/>
		/// number of bytes remaining in the input file.  This will happen if the input<br/>
		/// file size is an exact multiple of the buffer size.<br/>
		/// If gzeof() returns true, then the read functions will return no more data,<br/>
		/// unless the end-of-file indicator is reset by gzclearerr() and the input file<br/>
		/// has grown since the previous end of file was detected.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DirectNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[48])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[48])(file);
			#endif
		}

		/// <summary>
		/// Return true (1) if the end-of-file indicator for file has been set while<br/>
		/// reading, false (0) otherwise.  Note that the end-of-file indicator is set<br/>
		/// only if the read tried to go past the end of the input, but came up short.<br/>
		/// Therefore, just like feof(), gzeof() may return false even if there is no<br/>
		/// more data to read, in the event that the last read request was for the exact<br/>
		/// number of bytes remaining in the input file.  This will happen if the input<br/>
		/// file size is an exact multiple of the buffer size.<br/>
		/// If gzeof() returns true, then the read functions will return no more data,<br/>
		/// unless the end-of-file indicator is reset by gzclearerr() and the input file<br/>
		/// has grown since the previous end of file was detected.<br/>
		/// </summary>
		public static int Direct(GzFile file)
		{
			int ret = DirectNative(file);
			return ret;
		}

		/// <summary>
		/// Return true (1) if file is being copied directly while reading, or false<br/>
		/// (0) if file is a gzip stream being decompressed.<br/>
		/// If the input file is empty, gzdirect() will return true, since the input<br/>
		/// does not contain a gzip stream.<br/>
		/// If gzdirect() is used immediately after gzopen() or gzdopen() it will<br/>
		/// cause buffers to be allocated to allow reading the file to determine if it<br/>
		/// is a gzip file.  Therefore if gzbuffer() is used, it should be called before<br/>
		/// gzdirect().<br/>
		/// When writing, gzdirect() returns true (1) if transparent writing was<br/>
		/// requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:<br/>
		/// gzdirect() is not needed when writing.  Transparent writing must be<br/>
		/// explicitly requested, so the application already knows the answer.  When<br/>
		/// linking statically, using gzdirect() will include all of the zlib code for<br/>
		/// gzip file reading and decompression, which may not be desired.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CloseNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[49])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[49])(file);
			#endif
		}

		/// <summary>
		/// Return true (1) if file is being copied directly while reading, or false<br/>
		/// (0) if file is a gzip stream being decompressed.<br/>
		/// If the input file is empty, gzdirect() will return true, since the input<br/>
		/// does not contain a gzip stream.<br/>
		/// If gzdirect() is used immediately after gzopen() or gzdopen() it will<br/>
		/// cause buffers to be allocated to allow reading the file to determine if it<br/>
		/// is a gzip file.  Therefore if gzbuffer() is used, it should be called before<br/>
		/// gzdirect().<br/>
		/// When writing, gzdirect() returns true (1) if transparent writing was<br/>
		/// requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:<br/>
		/// gzdirect() is not needed when writing.  Transparent writing must be<br/>
		/// explicitly requested, so the application already knows the answer.  When<br/>
		/// linking statically, using gzdirect() will include all of the zlib code for<br/>
		/// gzip file reading and decompression, which may not be desired.)<br/>
		/// </summary>
		public static int Close(GzFile file)
		{
			int ret = CloseNative(file);
			return ret;
		}

		/// <summary>
		/// Flush all pending output for file, if necessary, close file and<br/>
		/// deallocate the (de)compression state.  Note that once file is closed, you<br/>
		/// cannot call gzerror with file, since its structures have been deallocated.<br/>
		/// gzclose must not be called more than once on the same file, just as free<br/>
		/// must not be called more than once on the same allocation.<br/>
		/// gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a<br/>
		/// file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the<br/>
		/// last read ended in the middle of a gzip stream, or Z_OK on success.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CloseRNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[50])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[50])(file);
			#endif
		}

		/// <summary>
		/// Flush all pending output for file, if necessary, close file and<br/>
		/// deallocate the (de)compression state.  Note that once file is closed, you<br/>
		/// cannot call gzerror with file, since its structures have been deallocated.<br/>
		/// gzclose must not be called more than once on the same file, just as free<br/>
		/// must not be called more than once on the same allocation.<br/>
		/// gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a<br/>
		/// file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the<br/>
		/// last read ended in the middle of a gzip stream, or Z_OK on success.<br/>
		/// </summary>
		public static int CloseR(GzFile file)
		{
			int ret = CloseRNative(file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CloseWNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[51])(file);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[51])(file);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int CloseW(GzFile file)
		{
			int ret = CloseWNative(file);
			return ret;
		}

		/// <summary>
		/// Same as gzclose(), but gzclose_r() is only for use when reading, and<br/>
		/// gzclose_w() is only for use when writing or appending.  The advantage to<br/>
		/// using these instead of gzclose() is that they avoid linking in zlib<br/>
		/// compression or decompression code that is not used when only reading or only<br/>
		/// writing respectively.  If gzclose() is used, then both compression and<br/>
		/// decompression code will be included the application when linking to a static<br/>
		/// zlib library.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ErrorNative(GzFile file, int* errnum)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int*, byte*>)funcTable[52])(file, errnum);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GzFile, nint, nint>)funcTable[52])(file, (nint)errnum);
			#endif
		}

		/// <summary>
		/// Same as gzclose(), but gzclose_r() is only for use when reading, and<br/>
		/// gzclose_w() is only for use when writing or appending.  The advantage to<br/>
		/// using these instead of gzclose() is that they avoid linking in zlib<br/>
		/// compression or decompression code that is not used when only reading or only<br/>
		/// writing respectively.  If gzclose() is used, then both compression and<br/>
		/// decompression code will be included the application when linking to a static<br/>
		/// zlib library.<br/>
		/// </summary>
		public static byte* Error(GzFile file, int* errnum)
		{
			byte* ret = ErrorNative(file, errnum);
			return ret;
		}

		/// <summary>
		/// Same as gzclose(), but gzclose_r() is only for use when reading, and<br/>
		/// gzclose_w() is only for use when writing or appending.  The advantage to<br/>
		/// using these instead of gzclose() is that they avoid linking in zlib<br/>
		/// compression or decompression code that is not used when only reading or only<br/>
		/// writing respectively.  If gzclose() is used, then both compression and<br/>
		/// decompression code will be included the application when linking to a static<br/>
		/// zlib library.<br/>
		/// </summary>
		public static string ErrorS(GzFile file, int* errnum)
		{
			string ret = Utils.DecodeStringUTF8(ErrorNative(file, errnum));
			return ret;
		}

		/// <summary>
		/// Same as gzclose(), but gzclose_r() is only for use when reading, and<br/>
		/// gzclose_w() is only for use when writing or appending.  The advantage to<br/>
		/// using these instead of gzclose() is that they avoid linking in zlib<br/>
		/// compression or decompression code that is not used when only reading or only<br/>
		/// writing respectively.  If gzclose() is used, then both compression and<br/>
		/// decompression code will be included the application when linking to a static<br/>
		/// zlib library.<br/>
		/// </summary>
		public static byte* Error(GzFile file, ref int errnum)
		{
			fixed (int* perrnum = &errnum)
			{
				byte* ret = ErrorNative(file, (int*)perrnum);
				return ret;
			}
		}

		/// <summary>
		/// Same as gzclose(), but gzclose_r() is only for use when reading, and<br/>
		/// gzclose_w() is only for use when writing or appending.  The advantage to<br/>
		/// using these instead of gzclose() is that they avoid linking in zlib<br/>
		/// compression or decompression code that is not used when only reading or only<br/>
		/// writing respectively.  If gzclose() is used, then both compression and<br/>
		/// decompression code will be included the application when linking to a static<br/>
		/// zlib library.<br/>
		/// </summary>
		public static string ErrorS(GzFile file, ref int errnum)
		{
			fixed (int* perrnum = &errnum)
			{
				string ret = Utils.DecodeStringUTF8(ErrorNative(file, (int*)perrnum));
				return ret;
			}
		}

		/// <summary>
		/// Return the error message for the last error which occurred on file.<br/>
		/// errnum is set to zlib error number.  If an error occurred in the file system<br/>
		/// and not in the compression library, errnum is set to Z_ERRNO and the<br/>
		/// application may consult errno to get the exact error code.<br/>
		/// The application must not modify the returned string.  Future calls to<br/>
		/// this function may invalidate the previously returned string.  If file is<br/>
		/// closed, then the string previously returned by gzerror will no longer be<br/>
		/// available.<br/>
		/// gzerror() should be used to distinguish errors from end-of-file for those<br/>
		/// functions above that do not distinguish those cases in their return values.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearerrNative(GzFile file)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GzFile, void>)funcTable[53])(file);
			#else
			((delegate* unmanaged[Cdecl]<GzFile, void>)funcTable[53])(file);
			#endif
		}

		/// <summary>
		/// Return the error message for the last error which occurred on file.<br/>
		/// errnum is set to zlib error number.  If an error occurred in the file system<br/>
		/// and not in the compression library, errnum is set to Z_ERRNO and the<br/>
		/// application may consult errno to get the exact error code.<br/>
		/// The application must not modify the returned string.  Future calls to<br/>
		/// this function may invalidate the previously returned string.  If file is<br/>
		/// closed, then the string previously returned by gzerror will no longer be<br/>
		/// available.<br/>
		/// gzerror() should be used to distinguish errors from end-of-file for those<br/>
		/// functions above that do not distinguish those cases in their return values.<br/>
		/// </summary>
		public static void Clearerr(GzFile file)
		{
			ClearerrNative(file);
		}

		/// <summary>
		/// These functions are not related to compression but are exported<br/>
		/// anyway because they might be useful in applications using the compression<br/>
		/// library.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Adler32Native(uint adler, byte* buf, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint, uint>)funcTable[54])(adler, buf, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint, uint>)funcTable[54])(adler, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// These functions are not related to compression but are exported<br/>
		/// anyway because they might be useful in applications using the compression<br/>
		/// library.<br/>
		/// </summary>
		public static uint Adler32(uint adler, byte* buf, uint len)
		{
			uint ret = Adler32Native(adler, buf, len);
			return ret;
		}

		/// <summary>
		/// These functions are not related to compression but are exported<br/>
		/// anyway because they might be useful in applications using the compression<br/>
		/// library.<br/>
		/// </summary>
		public static uint Adler32(uint adler, ref byte buf, uint len)
		{
			fixed (byte* pbuf = &buf)
			{
				uint ret = Adler32Native(adler, (byte*)pbuf, len);
				return ret;
			}
		}

		/// <summary>
		/// Update a running Adler-32 checksum with the bytes buf[0..len-1] and<br/>
		/// return the updated checksum. An Adler-32 value is in the range of a 32-bit<br/>
		/// unsigned integer. If buf is Z_NULL, this function returns the required<br/>
		/// initial value for the checksum.<br/>
		/// An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed<br/>
		/// much faster.<br/>
		/// Usage example:<br/>
		/// uLong adler = adler32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// adler = adler32(adler, buffer, length);<br/>
		/// }<br/>
		/// if (adler != original_adler) error();<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Adler32ZNative(uint adler, byte* buf, nint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, nint, uint>)funcTable[55])(adler, buf, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, nint, uint>)funcTable[55])(adler, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Update a running Adler-32 checksum with the bytes buf[0..len-1] and<br/>
		/// return the updated checksum. An Adler-32 value is in the range of a 32-bit<br/>
		/// unsigned integer. If buf is Z_NULL, this function returns the required<br/>
		/// initial value for the checksum.<br/>
		/// An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed<br/>
		/// much faster.<br/>
		/// Usage example:<br/>
		/// uLong adler = adler32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// adler = adler32(adler, buffer, length);<br/>
		/// }<br/>
		/// if (adler != original_adler) error();<br/>
		/// </summary>
		public static uint Adler32Z(uint adler, byte* buf, nint len)
		{
			uint ret = Adler32ZNative(adler, buf, len);
			return ret;
		}

		/// <summary>
		/// Update a running Adler-32 checksum with the bytes buf[0..len-1] and<br/>
		/// return the updated checksum. An Adler-32 value is in the range of a 32-bit<br/>
		/// unsigned integer. If buf is Z_NULL, this function returns the required<br/>
		/// initial value for the checksum.<br/>
		/// An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed<br/>
		/// much faster.<br/>
		/// Usage example:<br/>
		/// uLong adler = adler32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// adler = adler32(adler, buffer, length);<br/>
		/// }<br/>
		/// if (adler != original_adler) error();<br/>
		/// </summary>
		public static uint Adler32Z(uint adler, ref byte buf, nint len)
		{
			fixed (byte* pbuf = &buf)
			{
				uint ret = Adler32ZNative(adler, (byte*)pbuf, len);
				return ret;
			}
		}

		/// <summary>
		/// ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,<br/>
		/// z_off_t len2);<br/>
		/// Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1<br/>
		/// and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for<br/>
		/// each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of<br/>
		/// seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note<br/>
		/// that the z_off_t type (like off_t) is a signed integer.  If len2 is<br/>
		/// negative, the result has no meaning or utility.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32Native(uint crc, byte* buf, uint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint, uint>)funcTable[56])(crc, buf, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint, uint>)funcTable[56])(crc, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,<br/>
		/// z_off_t len2);<br/>
		/// Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1<br/>
		/// and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for<br/>
		/// each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of<br/>
		/// seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note<br/>
		/// that the z_off_t type (like off_t) is a signed integer.  If len2 is<br/>
		/// negative, the result has no meaning or utility.<br/>
		/// </summary>
		public static uint Crc32(uint crc, byte* buf, uint len)
		{
			uint ret = Crc32Native(crc, buf, len);
			return ret;
		}

		/// <summary>
		/// ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,<br/>
		/// z_off_t len2);<br/>
		/// Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1<br/>
		/// and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for<br/>
		/// each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of<br/>
		/// seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note<br/>
		/// that the z_off_t type (like off_t) is a signed integer.  If len2 is<br/>
		/// negative, the result has no meaning or utility.<br/>
		/// </summary>
		public static uint Crc32(uint crc, ref byte buf, uint len)
		{
			fixed (byte* pbuf = &buf)
			{
				uint ret = Crc32Native(crc, (byte*)pbuf, len);
				return ret;
			}
		}

		/// <summary>
		/// Update a running CRC-32 with the bytes buf[0..len-1] and return the<br/>
		/// updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.<br/>
		/// If buf is Z_NULL, this function returns the required initial value for the<br/>
		/// crc. Pre- and post-conditioning (one's complement) is performed within this<br/>
		/// function so it shouldn't be done by the application.<br/>
		/// Usage example:<br/>
		/// uLong crc = crc32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// crc = crc32(crc, buffer, length);<br/>
		/// }<br/>
		/// if (crc != original_crc) error();<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32ZNative(uint crc, byte* buf, nint len)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, nint, uint>)funcTable[57])(crc, buf, len);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, nint, uint>)funcTable[57])(crc, (nint)buf, len);
			#endif
		}

		/// <summary>
		/// Update a running CRC-32 with the bytes buf[0..len-1] and return the<br/>
		/// updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.<br/>
		/// If buf is Z_NULL, this function returns the required initial value for the<br/>
		/// crc. Pre- and post-conditioning (one's complement) is performed within this<br/>
		/// function so it shouldn't be done by the application.<br/>
		/// Usage example:<br/>
		/// uLong crc = crc32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// crc = crc32(crc, buffer, length);<br/>
		/// }<br/>
		/// if (crc != original_crc) error();<br/>
		/// </summary>
		public static uint Crc32Z(uint crc, byte* buf, nint len)
		{
			uint ret = Crc32ZNative(crc, buf, len);
			return ret;
		}

		/// <summary>
		/// Update a running CRC-32 with the bytes buf[0..len-1] and return the<br/>
		/// updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.<br/>
		/// If buf is Z_NULL, this function returns the required initial value for the<br/>
		/// crc. Pre- and post-conditioning (one's complement) is performed within this<br/>
		/// function so it shouldn't be done by the application.<br/>
		/// Usage example:<br/>
		/// uLong crc = crc32(0L, Z_NULL, 0);<br/>
		/// while (read_buffer(buffer, length) != EOF) {<br/>
		/// crc = crc32(crc, buffer, length);<br/>
		/// }<br/>
		/// if (crc != original_crc) error();<br/>
		/// </summary>
		public static uint Crc32Z(uint crc, ref byte buf, nint len)
		{
			fixed (byte* pbuf = &buf)
			{
				uint ret = Crc32ZNative(crc, (byte*)pbuf, len);
				return ret;
			}
		}

		/// <summary>
		/// ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);<br/>
		/// Return the operator corresponding to length len2, to be used with<br/>
		/// crc32_combine_op(). len2 must be non-negative.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32CombineOpNative(uint crc1, uint crc2, uint op)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[58])(crc1, crc2, op);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, uint, uint>)funcTable[58])(crc1, crc2, op);
			#endif
		}

		/// <summary>
		/// ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);<br/>
		/// Return the operator corresponding to length len2, to be used with<br/>
		/// crc32_combine_op(). len2 must be non-negative.<br/>
		/// </summary>
		public static uint Crc32CombineOp(uint crc1, uint crc2, uint op)
		{
			uint ret = Crc32CombineOpNative(crc1, crc2, op);
			return ret;
		}

		/// <summary>
		/// deflateInit and inflateInit are macros to allow checking the zlib version<br/>
		/// and the compiler's view of z_stream:<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateInitNative(ZStream* strm, int level, byte* version, int streamSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, byte*, int, int>)funcTable[59])(strm, level, version, streamSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, int, int>)funcTable[59])((nint)strm, level, (nint)version, streamSize);
			#endif
		}

		/// <summary>
		/// deflateInit and inflateInit are macros to allow checking the zlib version<br/>
		/// and the compiler's view of z_stream:<br/>
		/// </summary>
		public static int DeflateInit(ZStream* strm, int level, byte* version, int streamSize)
		{
			int ret = DeflateInitNative(strm, level, version, streamSize);
			return ret;
		}

		/// <summary>
		/// deflateInit and inflateInit are macros to allow checking the zlib version<br/>
		/// and the compiler's view of z_stream:<br/>
		/// </summary>
		public static int DeflateInit(ZStream* strm, int level, ref byte version, int streamSize)
		{
			fixed (byte* pversion = &version)
			{
				int ret = DeflateInitNative(strm, level, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// deflateInit and inflateInit are macros to allow checking the zlib version<br/>
		/// and the compiler's view of z_stream:<br/>
		/// </summary>
		public static int DeflateInit(ZStream* strm, int level, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pversion = version)
			{
				int ret = DeflateInitNative(strm, level, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// deflateInit and inflateInit are macros to allow checking the zlib version<br/>
		/// and the compiler's view of z_stream:<br/>
		/// </summary>
		public static int DeflateInit(ZStream* strm, int level, string version, int streamSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (version != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(version);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DeflateInitNative(strm, level, pStr0, streamSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateInitNative(ZStream* strm, byte* version, int streamSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, byte*, int, int>)funcTable[60])(strm, version, streamSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int, int>)funcTable[60])((nint)strm, (nint)version, streamSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit(ZStream* strm, byte* version, int streamSize)
		{
			int ret = InflateInitNative(strm, version, streamSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit(ZStream* strm, ref byte version, int streamSize)
		{
			fixed (byte* pversion = &version)
			{
				int ret = InflateInitNative(strm, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit(ZStream* strm, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pversion = version)
			{
				int ret = InflateInitNative(strm, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit(ZStream* strm, string version, int streamSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (version != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(version);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = InflateInitNative(strm, pStr0, streamSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateInit2Native(ZStream* strm, int level, int method, int windowBits, int memLevel, int strategy, byte* version, int streamSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int, int, int, int, byte*, int, int>)funcTable[61])(strm, level, method, windowBits, memLevel, strategy, version, streamSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int, int, int, int, nint, int, int>)funcTable[61])((nint)strm, level, method, windowBits, memLevel, strategy, (nint)version, streamSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DeflateInit2(ZStream* strm, int level, int method, int windowBits, int memLevel, int strategy, byte* version, int streamSize)
		{
			int ret = DeflateInit2Native(strm, level, method, windowBits, memLevel, strategy, version, streamSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DeflateInit2(ZStream* strm, int level, int method, int windowBits, int memLevel, int strategy, ref byte version, int streamSize)
		{
			fixed (byte* pversion = &version)
			{
				int ret = DeflateInit2Native(strm, level, method, windowBits, memLevel, strategy, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DeflateInit2(ZStream* strm, int level, int method, int windowBits, int memLevel, int strategy, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pversion = version)
			{
				int ret = DeflateInit2Native(strm, level, method, windowBits, memLevel, strategy, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DeflateInit2(ZStream* strm, int level, int method, int windowBits, int memLevel, int strategy, string version, int streamSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (version != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(version);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = DeflateInit2Native(strm, level, method, windowBits, memLevel, strategy, pStr0, streamSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}
	}
}
