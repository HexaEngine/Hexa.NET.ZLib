// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ZLib
{
	public unsafe partial class ZLib
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateInit2Native(ZStream* strm, int windowBits, byte* version, int streamSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, byte*, int, int>)funcTable[62])(strm, windowBits, version, streamSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, int, int>)funcTable[62])((nint)strm, windowBits, (nint)version, streamSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit2(ZStream* strm, int windowBits, byte* version, int streamSize)
		{
			int ret = InflateInit2Native(strm, windowBits, version, streamSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit2(ZStream* strm, int windowBits, ref byte version, int streamSize)
		{
			fixed (byte* pversion = &version)
			{
				int ret = InflateInit2Native(strm, windowBits, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit2(ZStream* strm, int windowBits, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pversion = version)
			{
				int ret = InflateInit2Native(strm, windowBits, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateInit2(ZStream* strm, int windowBits, string version, int streamSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (version != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(version);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = InflateInit2Native(strm, windowBits, pStr0, streamSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateBackInitNative(ZStream* strm, int windowBits, byte* window, byte* version, int streamSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, byte*, byte*, int, int>)funcTable[63])(strm, windowBits, window, version, streamSize);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, nint, nint, int, int>)funcTable[63])((nint)strm, windowBits, (nint)window, (nint)version, streamSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, byte* window, byte* version, int streamSize)
		{
			int ret = InflateBackInitNative(strm, windowBits, window, version, streamSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, ref byte window, byte* version, int streamSize)
		{
			fixed (byte* pwindow = &window)
			{
				int ret = InflateBackInitNative(strm, windowBits, (byte*)pwindow, version, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, byte* window, ref byte version, int streamSize)
		{
			fixed (byte* pversion = &version)
			{
				int ret = InflateBackInitNative(strm, windowBits, window, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, byte* window, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pversion = version)
			{
				int ret = InflateBackInitNative(strm, windowBits, window, (byte*)pversion, streamSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, byte* window, string version, int streamSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (version != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(version);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = InflateBackInitNative(strm, windowBits, window, pStr0, streamSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, ref byte window, ref byte version, int streamSize)
		{
			fixed (byte* pwindow = &window)
			{
				fixed (byte* pversion = &version)
				{
					int ret = InflateBackInitNative(strm, windowBits, (byte*)pwindow, (byte*)pversion, streamSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, ref byte window, ReadOnlySpan<byte> version, int streamSize)
		{
			fixed (byte* pwindow = &window)
			{
				fixed (byte* pversion = version)
				{
					int ret = InflateBackInitNative(strm, windowBits, (byte*)pwindow, (byte*)pversion, streamSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateBackInit(ZStream* strm, int windowBits, ref byte window, string version, int streamSize)
		{
			fixed (byte* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (version != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(version);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(version, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = InflateBackInitNative(strm, windowBits, (byte*)pwindow, pStr0, streamSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GzFile OpenNative(byte* unknown0, byte* unknown1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, GzFile>)funcTable[64])(unknown0, unknown1);
			#else
			return (GzFile)((delegate* unmanaged[Cdecl]<nint, nint, GzFile>)funcTable[64])((nint)unknown0, (nint)unknown1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(byte* unknown0, byte* unknown1)
		{
			GzFile ret = OpenNative(unknown0, unknown1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(ref byte unknown0, byte* unknown1)
		{
			fixed (byte* punknown0 = &unknown0)
			{
				GzFile ret = OpenNative((byte*)punknown0, unknown1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(ReadOnlySpan<byte> unknown0, byte* unknown1)
		{
			fixed (byte* punknown0 = unknown0)
			{
				GzFile ret = OpenNative((byte*)punknown0, unknown1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(string unknown0, byte* unknown1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (unknown0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(unknown0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(unknown0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GzFile ret = OpenNative(pStr0, unknown1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(byte* unknown0, ref byte unknown1)
		{
			fixed (byte* punknown1 = &unknown1)
			{
				GzFile ret = OpenNative(unknown0, (byte*)punknown1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(byte* unknown0, ReadOnlySpan<byte> unknown1)
		{
			fixed (byte* punknown1 = unknown1)
			{
				GzFile ret = OpenNative(unknown0, (byte*)punknown1);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(byte* unknown0, string unknown1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (unknown1 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(unknown1);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(unknown1, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GzFile ret = OpenNative(unknown0, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(ref byte unknown0, ref byte unknown1)
		{
			fixed (byte* punknown0 = &unknown0)
			{
				fixed (byte* punknown1 = &unknown1)
				{
					GzFile ret = OpenNative((byte*)punknown0, (byte*)punknown1);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(ReadOnlySpan<byte> unknown0, ReadOnlySpan<byte> unknown1)
		{
			fixed (byte* punknown0 = unknown0)
			{
				fixed (byte* punknown1 = unknown1)
				{
					GzFile ret = OpenNative((byte*)punknown0, (byte*)punknown1);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile Open(string unknown0, string unknown1)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (unknown0 != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(unknown0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(unknown0, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (unknown1 != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(unknown1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(unknown1, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			GzFile ret = OpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SeekNative(GzFile unknown0, int unknown1, int unknown2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int, int, int>)funcTable[65])(unknown0, unknown1, unknown2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int, int, int>)funcTable[65])(unknown0, unknown1, unknown2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Seek(GzFile unknown0, int unknown1, int unknown2)
		{
			int ret = SeekNative(unknown0, unknown1, unknown2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TellNative(GzFile unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[66])(unknown0);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[66])(unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Tell(GzFile unknown0)
		{
			int ret = TellNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int OffsetNative(GzFile unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[67])(unknown0);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GzFile, int>)funcTable[67])(unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int Offset(GzFile unknown0)
		{
			int ret = OffsetNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Adler32CombineNative(uint unknown0, uint unknown1, int unknown2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, int, uint>)funcTable[68])(unknown0, unknown1, unknown2);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, int, uint>)funcTable[68])(unknown0, unknown1, unknown2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Adler32Combine(uint unknown0, uint unknown1, int unknown2)
		{
			uint ret = Adler32CombineNative(unknown0, unknown1, unknown2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32CombineNative(uint unknown0, uint unknown1, int unknown2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, int, uint>)funcTable[69])(unknown0, unknown1, unknown2);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint, int, uint>)funcTable[69])(unknown0, unknown1, unknown2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Crc32Combine(uint unknown0, uint unknown1, int unknown2)
		{
			uint ret = Crc32CombineNative(unknown0, unknown1, unknown2);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint Crc32CombineGenNative(int unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[70])(unknown0);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[70])(unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint Crc32CombineGen(int unknown0)
		{
			uint ret = Crc32CombineGenNative(unknown0);
			return ret;
		}

		/// <summary>
		/// undocumented functions <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ZErrorNative(int unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[71])(unknown0);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[71])(unknown0);
			#endif
		}

		/// <summary>
		/// undocumented functions <br/>
		/// </summary>
		public static byte* ZError(int unknown0)
		{
			byte* ret = ZErrorNative(unknown0);
			return ret;
		}

		/// <summary>
		/// undocumented functions <br/>
		/// </summary>
		public static string ZErrorS(int unknown0)
		{
			string ret = Utils.DecodeStringUTF8(ZErrorNative(unknown0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateSyncPointNative(ZStream* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[72])(unknown0);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[72])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateSyncPoint(ZStream* unknown0)
		{
			int ret = InflateSyncPointNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* GetCrcTableNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*>)funcTable[73])();
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<nint>)funcTable[73])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint* GetCrcTable()
		{
			uint* ret = GetCrcTableNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateUndermineNative(ZStream* unknown0, int unknown1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int>)funcTable[74])(unknown0, unknown1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[74])((nint)unknown0, unknown1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateUndermine(ZStream* unknown0, int unknown1)
		{
			int ret = InflateUndermineNative(unknown0, unknown1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateValidateNative(ZStream* unknown0, int unknown1)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int, int>)funcTable[75])(unknown0, unknown1);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[75])((nint)unknown0, unknown1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateValidate(ZStream* unknown0, int unknown1)
		{
			int ret = InflateValidateNative(unknown0, unknown1);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint InflateCodesUsedNative(ZStream* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, uint>)funcTable[76])(unknown0);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[76])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint InflateCodesUsed(ZStream* unknown0)
		{
			uint ret = InflateCodesUsedNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int InflateResetKeepNative(ZStream* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[77])(unknown0);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[77])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int InflateResetKeep(ZStream* unknown0)
		{
			int ret = InflateResetKeepNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DeflateResetKeepNative(ZStream* unknown0)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ZStream*, int>)funcTable[78])(unknown0);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[78])((nint)unknown0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int DeflateResetKeep(ZStream* unknown0)
		{
			int ret = DeflateResetKeepNative(unknown0);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GzFile OpenWNative(char* path, byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<char*, byte*, GzFile>)funcTable[79])(path, mode);
			#else
			return (GzFile)((delegate* unmanaged[Cdecl]<nint, nint, GzFile>)funcTable[79])((nint)path, (nint)mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(char* path, byte* mode)
		{
			GzFile ret = OpenWNative(path, mode);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(ref char path, byte* mode)
		{
			fixed (char* ppath = &path)
			{
				GzFile ret = OpenWNative((char*)ppath, mode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(ReadOnlySpan<char> path, byte* mode)
		{
			fixed (char* ppath = path)
			{
				GzFile ret = OpenWNative((char*)ppath, mode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(string path, byte* mode)
		{
			fixed (char* ppath = path)
			{
				GzFile ret = OpenWNative(ppath, mode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(char* path, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				GzFile ret = OpenWNative(path, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(char* path, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				GzFile ret = OpenWNative(path, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(char* path, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GzFile ret = OpenWNative(path, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(ref char path, ref byte mode)
		{
			fixed (char* ppath = &path)
			{
				fixed (byte* pmode = &mode)
				{
					GzFile ret = OpenWNative((char*)ppath, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(ReadOnlySpan<char> path, ReadOnlySpan<byte> mode)
		{
			fixed (char* ppath = path)
			{
				fixed (byte* pmode = mode)
				{
					GzFile ret = OpenWNative((char*)ppath, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static GzFile OpenW(string path, string mode)
		{
			fixed (char* ppath = path)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				GzFile ret = OpenWNative(ppath, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

	}
}
