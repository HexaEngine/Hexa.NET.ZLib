// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ZLib
{
	#if NET5_0_OR_GREATER
	/// <summary>
	/// used to allocate the internal state <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* Zalloc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] void* opaque, [NativeName(NativeNameType.Param, "items")] [NativeName(NativeNameType.Type, "uInt")] uint items, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "uInt")] uint size);

	#else
	/// <summary>
	/// used to allocate the internal state <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint Zalloc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] nint opaque, [NativeName(NativeNameType.Param, "items")] [NativeName(NativeNameType.Type, "uInt")] uint items, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "uInt")] uint size);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// used to free the internal state <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void Zfree([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] void* opaque, [NativeName(NativeNameType.Param, "address")] [NativeName(NativeNameType.Type, "voidpf")] void* address);

	#else
	/// <summary>
	/// used to free the internal state <br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void Zfree([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] nint opaque, [NativeName(NativeNameType.Param, "address")] [NativeName(NativeNameType.Type, "voidpf")] nint address);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// The 'zlib' compression library provides in-memory compression and<br/>
	/// decompression functions, including integrity checks of the uncompressed data.<br/>
	/// This version of the library supports only one compression method (deflation)<br/>
	/// but other algorithms will be added later and will have the same stream<br/>
	/// interface.<br/>
	/// Compression can be done in a single step if the buffers are large enough,<br/>
	/// or can be done by repeated calls of the compression function.  In the latter<br/>
	/// case, the application must provide more input and/or consume the output<br/>
	/// (providing more output space) before each call.<br/>
	/// The compressed data format used by default by the in-memory functions is<br/>
	/// the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped<br/>
	/// around a deflate stream, which is itself documented in RFC 1951.<br/>
	/// The library also supports reading and writing files in gzip (.gz) format<br/>
	/// with an interface similar to that of stdio using the functions that start<br/>
	/// with "gz".  The gzip format is different from the zlib format.  gzip is a<br/>
	/// gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.<br/>
	/// This library can optionally read and write gzip and raw deflate streams in<br/>
	/// memory as well.<br/>
	/// The zlib format was designed to be compact and fast for use in memory<br/>
	/// and on communications channels.  The gzip format was designed for single-<br/>
	/// file compression on file systems, has a larger header than zlib to maintain<br/>
	/// directory information, and uses a different, slower check method than zlib.<br/>
	/// The library does not install any signal handler.  The decoder checks<br/>
	/// the consistency of the compressed data, so the library should never crash<br/>
	/// even in the case of corrupted input.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* AllocFunc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] void* opaque, [NativeName(NativeNameType.Param, "items")] [NativeName(NativeNameType.Type, "uInt")] uint items, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "uInt")] uint size);

	#else
	/// <summary>
	/// The 'zlib' compression library provides in-memory compression and<br/>
	/// decompression functions, including integrity checks of the uncompressed data.<br/>
	/// This version of the library supports only one compression method (deflation)<br/>
	/// but other algorithms will be added later and will have the same stream<br/>
	/// interface.<br/>
	/// Compression can be done in a single step if the buffers are large enough,<br/>
	/// or can be done by repeated calls of the compression function.  In the latter<br/>
	/// case, the application must provide more input and/or consume the output<br/>
	/// (providing more output space) before each call.<br/>
	/// The compressed data format used by default by the in-memory functions is<br/>
	/// the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped<br/>
	/// around a deflate stream, which is itself documented in RFC 1951.<br/>
	/// The library also supports reading and writing files in gzip (.gz) format<br/>
	/// with an interface similar to that of stdio using the functions that start<br/>
	/// with "gz".  The gzip format is different from the zlib format.  gzip is a<br/>
	/// gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.<br/>
	/// This library can optionally read and write gzip and raw deflate streams in<br/>
	/// memory as well.<br/>
	/// The zlib format was designed to be compact and fast for use in memory<br/>
	/// and on communications channels.  The gzip format was designed for single-<br/>
	/// file compression on file systems, has a larger header than zlib to maintain<br/>
	/// directory information, and uses a different, slower check method than zlib.<br/>
	/// The library does not install any signal handler.  The decoder checks<br/>
	/// the consistency of the compressed data, so the library should never crash<br/>
	/// even in the case of corrupted input.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint AllocFunc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] nint opaque, [NativeName(NativeNameType.Param, "items")] [NativeName(NativeNameType.Type, "uInt")] uint items, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "uInt")] uint size);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void FreeFunc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] void* opaque, [NativeName(NativeNameType.Param, "address")] [NativeName(NativeNameType.Type, "voidpf")] void* address);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void FreeFunc([NativeName(NativeNameType.Param, "opaque")] [NativeName(NativeNameType.Type, "voidpf")] nint opaque, [NativeName(NativeNameType.Param, "address")] [NativeName(NativeNameType.Type, "voidpf")] nint address);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// ZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,<br/>
	/// unsigned char FAR *window);<br/>
	/// Initialize the internal stream state for decompression using inflateBack()<br/>
	/// calls.  The fields zalloc, zfree and opaque in strm must be initialized<br/>
	/// before the call.  If zalloc and zfree are Z_NULL, then the default library-<br/>
	/// derived memory allocation routines are used.  windowBits is the base two<br/>
	/// logarithm of the window size, in the range 8..15.  window is a caller<br/>
	/// supplied buffer of that size.  Except for special applications where it is<br/>
	/// assured that deflate was used with small window sizes, windowBits must be 15<br/>
	/// and a 32K byte window must be supplied to be able to decompress general<br/>
	/// deflate streams.<br/>
	/// See inflateBack() for the usage of these routines.<br/>
	/// inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of<br/>
	/// the parameters are invalid, Z_MEM_ERROR if the internal state could not be<br/>
	/// allocated, or Z_VERSION_ERROR if the version of the library does not match<br/>
	/// the version of the header file.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate uint InFunc([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "void *")] void* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned char * *")] byte** unknown1);

	#else
	/// <summary>
	/// ZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,<br/>
	/// unsigned char FAR *window);<br/>
	/// Initialize the internal stream state for decompression using inflateBack()<br/>
	/// calls.  The fields zalloc, zfree and opaque in strm must be initialized<br/>
	/// before the call.  If zalloc and zfree are Z_NULL, then the default library-<br/>
	/// derived memory allocation routines are used.  windowBits is the base two<br/>
	/// logarithm of the window size, in the range 8..15.  window is a caller<br/>
	/// supplied buffer of that size.  Except for special applications where it is<br/>
	/// assured that deflate was used with small window sizes, windowBits must be 15<br/>
	/// and a 32K byte window must be supplied to be able to decompress general<br/>
	/// deflate streams.<br/>
	/// See inflateBack() for the usage of these routines.<br/>
	/// inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of<br/>
	/// the parameters are invalid, Z_MEM_ERROR if the internal state could not be<br/>
	/// allocated, or Z_VERSION_ERROR if the version of the library does not match<br/>
	/// the version of the header file.<br/>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate uint InFunc([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "void *")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned char * *")] nint unknown1);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int OutFunc([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "void *")] void* unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned char *")] byte* unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned int")] uint unknown2);

	#else
	/// <summary>
	/// To be documented.
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate int OutFunc([NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "void *")] nint unknown0, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned char *")] nint unknown1, [NativeName(NativeNameType.Param, "")] [NativeName(NativeNameType.Type, "unsigned int")] uint unknown2);

	#endif

}
